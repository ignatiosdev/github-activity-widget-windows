{"version":3,"file":"vendors-node_modules_primer_behaviors_dist_esm_index_mjs-xxxxxxxxxxxx.js","mappings":"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","sources":["node_modules/@primer/behaviors/dist/esm/focus-trap.mjs","node_modules/@primer/behaviors/dist/esm/anchored-position.mjs","node_modules/@primer/behaviors/dist/esm/focus-zone.mjs","node_modules/@primer/behaviors/dist/esm/polyfills/event-listener-signal.mjs","node_modules/@primer/behaviors/dist/esm/utils/unique-id.mjs","node_modules/@primer/behaviors/dist/esm/scroll-into-view.mjs","node_modules/@primer/behaviors/dist/esm/dimensions.mjs","node_modules/@primer/behaviors/dist/esm/utils/iterate-focusable-elements.mjs","node_modules/@primer/behaviors/dist/esm/utils/user-agent.mjs"],"sourcesContent":["import { getFocusableChild, isTabbable } from './utils/iterate-focusable-elements.mjs';\nimport { polyfill } from './polyfills/event-listener-signal.mjs';\n\npolyfill();\nconst suspendedTrapStack = [];\nlet activeTrap = undefined;\nfunction tryReactivate() {\n    const trapToReactivate = suspendedTrapStack.pop();\n    if (trapToReactivate) {\n        focusTrap(trapToReactivate.container, trapToReactivate.initialFocus, trapToReactivate.originalSignal);\n    }\n}\nfunction followSignal(signal) {\n    const controller = new AbortController();\n    signal.addEventListener('abort', () => {\n        controller.abort();\n    });\n    return controller;\n}\nfunction observeFocusTrap(container, sentinels) {\n    const observer = new MutationObserver(mutations => {\n        for (const mutation of mutations) {\n            if (mutation.type === 'childList' && mutation.addedNodes.length) {\n                const sentinelChildren = Array.from(mutation.addedNodes).filter(e => e instanceof HTMLElement && e.classList.contains('sentinel') && e.tagName === 'SPAN');\n                if (sentinelChildren.length) {\n                    return;\n                }\n                const firstChild = container.firstElementChild;\n                const lastChild = container.lastElementChild;\n                const [sentinelStart, sentinelEnd] = sentinels;\n                if (!(firstChild === null || firstChild === void 0 ? void 0 : firstChild.classList.contains('sentinel'))) {\n                    container.insertAdjacentElement('afterbegin', sentinelStart);\n                }\n                if (!(lastChild === null || lastChild === void 0 ? void 0 : lastChild.classList.contains('sentinel'))) {\n                    container.insertAdjacentElement('beforeend', sentinelEnd);\n                }\n            }\n        }\n    });\n    observer.observe(container, { childList: true });\n    return observer;\n}\nfunction focusTrap(container, initialFocus, abortSignal) {\n    const controller = new AbortController();\n    const signal = abortSignal !== null && abortSignal !== void 0 ? abortSignal : controller.signal;\n    container.setAttribute('data-focus-trap', 'active');\n    const sentinelStart = document.createElement('span');\n    sentinelStart.setAttribute('class', 'sentinel');\n    sentinelStart.setAttribute('tabindex', '0');\n    sentinelStart.setAttribute('aria-hidden', 'true');\n    sentinelStart.onfocus = () => {\n        const lastFocusableChild = getFocusableChild(container, true);\n        lastFocusableChild === null || lastFocusableChild === void 0 ? void 0 : lastFocusableChild.focus();\n    };\n    const sentinelEnd = document.createElement('span');\n    sentinelEnd.setAttribute('class', 'sentinel');\n    sentinelEnd.setAttribute('tabindex', '0');\n    sentinelEnd.setAttribute('aria-hidden', 'true');\n    sentinelEnd.onfocus = () => {\n        const firstFocusableChild = getFocusableChild(container);\n        firstFocusableChild === null || firstFocusableChild === void 0 ? void 0 : firstFocusableChild.focus();\n    };\n    container.prepend(sentinelStart);\n    container.append(sentinelEnd);\n    const observer = observeFocusTrap(container, [sentinelStart, sentinelEnd]);\n    let lastFocusedChild = undefined;\n    function ensureTrapZoneHasFocus(focusedElement) {\n        if (focusedElement instanceof HTMLElement && document.contains(container)) {\n            if (container.contains(focusedElement)) {\n                lastFocusedChild = focusedElement;\n                return;\n            }\n            else {\n                if (lastFocusedChild && isTabbable(lastFocusedChild) && container.contains(lastFocusedChild)) {\n                    lastFocusedChild.focus();\n                    return;\n                }\n                else if (initialFocus && container.contains(initialFocus)) {\n                    initialFocus.focus();\n                    return;\n                }\n                else {\n                    const firstFocusableChild = getFocusableChild(container);\n                    firstFocusableChild === null || firstFocusableChild === void 0 ? void 0 : firstFocusableChild.focus();\n                    return;\n                }\n            }\n        }\n    }\n    const wrappingController = followSignal(signal);\n    if (activeTrap) {\n        const suspendedTrap = activeTrap;\n        activeTrap.container.setAttribute('data-focus-trap', 'suspended');\n        activeTrap.controller.abort();\n        suspendedTrapStack.push(suspendedTrap);\n    }\n    wrappingController.signal.addEventListener('abort', () => {\n        activeTrap = undefined;\n    });\n    signal.addEventListener('abort', () => {\n        container.removeAttribute('data-focus-trap');\n        const sentinels = container.getElementsByClassName('sentinel');\n        while (sentinels.length > 0)\n            sentinels[0].remove();\n        const suspendedTrapIndex = suspendedTrapStack.findIndex(t => t.container === container);\n        if (suspendedTrapIndex >= 0) {\n            suspendedTrapStack.splice(suspendedTrapIndex, 1);\n        }\n        observer.disconnect();\n        tryReactivate();\n    });\n    document.addEventListener('focus', event => {\n        ensureTrapZoneHasFocus(event.target);\n    }, { signal: wrappingController.signal, capture: true });\n    ensureTrapZoneHasFocus(document.activeElement);\n    activeTrap = {\n        container,\n        controller: wrappingController,\n        initialFocus,\n        originalSignal: signal,\n    };\n    const suspendedTrapIndex = suspendedTrapStack.findIndex(t => t.container === container);\n    if (suspendedTrapIndex >= 0) {\n        suspendedTrapStack.splice(suspendedTrapIndex, 1);\n    }\n    if (!abortSignal) {\n        return controller;\n    }\n}\n\nexport { focusTrap };\n","const alternateOrders = {\n    'outside-top': ['outside-bottom', 'outside-right', 'outside-left', 'outside-bottom'],\n    'outside-bottom': ['outside-top', 'outside-right', 'outside-left', 'outside-bottom'],\n    'outside-left': ['outside-right', 'outside-bottom', 'outside-top', 'outside-bottom'],\n    'outside-right': ['outside-left', 'outside-bottom', 'outside-top', 'outside-bottom'],\n};\nconst alternateAlignments = {\n    start: ['end', 'center'],\n    end: ['start', 'center'],\n    center: ['end', 'start'],\n};\nfunction getAnchoredPosition(floatingElement, anchorElement, settings = {}) {\n    const parentElement = getPositionedParent(floatingElement);\n    const clippingRect = getClippingRect(parentElement);\n    const parentElementStyle = getComputedStyle(parentElement);\n    const parentElementRect = parentElement.getBoundingClientRect();\n    const [borderTop, borderLeft] = [parentElementStyle.borderTopWidth, parentElementStyle.borderLeftWidth].map(v => parseInt(v, 10) || 0);\n    const relativeRect = {\n        top: parentElementRect.top + borderTop,\n        left: parentElementRect.left + borderLeft,\n    };\n    return pureCalculateAnchoredPosition(clippingRect, relativeRect, floatingElement.getBoundingClientRect(), anchorElement instanceof Element ? anchorElement.getBoundingClientRect() : anchorElement, getDefaultSettings(settings));\n}\nfunction getPositionedParent(element) {\n    if (isOnTopLayer(element))\n        return document.body;\n    let parentNode = element.parentNode;\n    while (parentNode !== null) {\n        if (parentNode instanceof HTMLElement && getComputedStyle(parentNode).position !== 'static') {\n            return parentNode;\n        }\n        parentNode = parentNode.parentNode;\n    }\n    return document.body;\n}\nfunction isOnTopLayer(element) {\n    var _a;\n    if (element.tagName === 'DIALOG') {\n        return true;\n    }\n    try {\n        if (element.matches(':popover-open') && /native code/.test((_a = document.body.showPopover) === null || _a === void 0 ? void 0 : _a.toString())) {\n            return true;\n        }\n    }\n    catch (_b) {\n        return false;\n    }\n    return false;\n}\nfunction getClippingRect(element) {\n    let parentNode = element;\n    while (parentNode !== null) {\n        if (!(parentNode instanceof Element)) {\n            break;\n        }\n        const parentNodeStyle = getComputedStyle(parentNode);\n        if (parentNodeStyle.overflow !== 'visible') {\n            break;\n        }\n        parentNode = parentNode.parentNode;\n    }\n    const clippingNode = parentNode === document.body || !(parentNode instanceof HTMLElement) ? document.body : parentNode;\n    const elemRect = clippingNode.getBoundingClientRect();\n    const elemStyle = getComputedStyle(clippingNode);\n    const [borderTop, borderLeft, borderRight, borderBottom] = [\n        elemStyle.borderTopWidth,\n        elemStyle.borderLeftWidth,\n        elemStyle.borderRightWidth,\n        elemStyle.borderBottomWidth,\n    ].map(v => parseInt(v, 10) || 0);\n    return {\n        top: elemRect.top + borderTop,\n        left: elemRect.left + borderLeft,\n        width: elemRect.width - borderRight - borderLeft,\n        height: Math.max(elemRect.height - borderTop - borderBottom, clippingNode === document.body ? window.innerHeight : -Infinity),\n    };\n}\nconst positionDefaults = {\n    side: 'outside-bottom',\n    align: 'start',\n    anchorOffset: 4,\n    alignmentOffset: 4,\n    allowOutOfBounds: false,\n};\nfunction getDefaultSettings(settings = {}) {\n    var _a, _b, _c, _d, _e;\n    const side = (_a = settings.side) !== null && _a !== void 0 ? _a : positionDefaults.side;\n    const align = (_b = settings.align) !== null && _b !== void 0 ? _b : positionDefaults.align;\n    return {\n        side,\n        align,\n        anchorOffset: (_c = settings.anchorOffset) !== null && _c !== void 0 ? _c : (side === 'inside-center' ? 0 : positionDefaults.anchorOffset),\n        alignmentOffset: (_d = settings.alignmentOffset) !== null && _d !== void 0 ? _d : (align !== 'center' && side.startsWith('inside') ? positionDefaults.alignmentOffset : 0),\n        allowOutOfBounds: (_e = settings.allowOutOfBounds) !== null && _e !== void 0 ? _e : positionDefaults.allowOutOfBounds,\n    };\n}\nfunction pureCalculateAnchoredPosition(viewportRect, relativePosition, floatingRect, anchorRect, { side, align, allowOutOfBounds, anchorOffset, alignmentOffset }) {\n    const relativeViewportRect = {\n        top: viewportRect.top - relativePosition.top,\n        left: viewportRect.left - relativePosition.left,\n        width: viewportRect.width,\n        height: viewportRect.height,\n    };\n    let pos = calculatePosition(floatingRect, anchorRect, side, align, anchorOffset, alignmentOffset);\n    let anchorSide = side;\n    let anchorAlign = align;\n    pos.top -= relativePosition.top;\n    pos.left -= relativePosition.left;\n    if (!allowOutOfBounds) {\n        const alternateOrder = alternateOrders[side];\n        let positionAttempt = 0;\n        if (alternateOrder) {\n            let prevSide = side;\n            while (positionAttempt < alternateOrder.length &&\n                shouldRecalculatePosition(prevSide, pos, relativeViewportRect, floatingRect)) {\n                const nextSide = alternateOrder[positionAttempt++];\n                prevSide = nextSide;\n                pos = calculatePosition(floatingRect, anchorRect, nextSide, align, anchorOffset, alignmentOffset);\n                pos.top -= relativePosition.top;\n                pos.left -= relativePosition.left;\n                anchorSide = nextSide;\n            }\n        }\n        const alternateAlignment = alternateAlignments[align];\n        let alignmentAttempt = 0;\n        if (alternateAlignment) {\n            let prevAlign = align;\n            while (alignmentAttempt < alternateAlignment.length &&\n                shouldRecalculateAlignment(prevAlign, pos, relativeViewportRect, floatingRect)) {\n                const nextAlign = alternateAlignment[alignmentAttempt++];\n                prevAlign = nextAlign;\n                pos = calculatePosition(floatingRect, anchorRect, anchorSide, nextAlign, anchorOffset, alignmentOffset);\n                pos.top -= relativePosition.top;\n                pos.left -= relativePosition.left;\n                anchorAlign = nextAlign;\n            }\n        }\n        if (pos.top < relativeViewportRect.top) {\n            pos.top = relativeViewportRect.top;\n        }\n        if (pos.left < relativeViewportRect.left) {\n            pos.left = relativeViewportRect.left;\n        }\n        if (pos.left + floatingRect.width > viewportRect.width + relativeViewportRect.left) {\n            pos.left = viewportRect.width + relativeViewportRect.left - floatingRect.width;\n        }\n        if (alternateOrder && positionAttempt < alternateOrder.length) {\n            if (pos.top + floatingRect.height > viewportRect.height + relativeViewportRect.top) {\n                pos.top = Math.max(viewportRect.height + relativeViewportRect.top - floatingRect.height, 0);\n            }\n        }\n    }\n    return Object.assign(Object.assign({}, pos), { anchorSide, anchorAlign });\n}\nfunction calculatePosition(elementDimensions, anchorPosition, side, align, anchorOffset, alignmentOffset) {\n    const anchorRight = anchorPosition.left + anchorPosition.width;\n    const anchorBottom = anchorPosition.top + anchorPosition.height;\n    let top = -1;\n    let left = -1;\n    if (side === 'outside-top') {\n        top = anchorPosition.top - anchorOffset - elementDimensions.height;\n    }\n    else if (side === 'outside-bottom') {\n        top = anchorBottom + anchorOffset;\n    }\n    else if (side === 'outside-left') {\n        left = anchorPosition.left - anchorOffset - elementDimensions.width;\n    }\n    else if (side === 'outside-right') {\n        left = anchorRight + anchorOffset;\n    }\n    if (side === 'outside-top' || side === 'outside-bottom') {\n        if (align === 'start') {\n            left = anchorPosition.left + alignmentOffset;\n        }\n        else if (align === 'center') {\n            left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n        }\n        else {\n            left = anchorRight - elementDimensions.width - alignmentOffset;\n        }\n    }\n    if (side === 'outside-left' || side === 'outside-right') {\n        if (align === 'start') {\n            top = anchorPosition.top + alignmentOffset;\n        }\n        else if (align === 'center') {\n            top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n        }\n        else {\n            top = anchorBottom - elementDimensions.height - alignmentOffset;\n        }\n    }\n    if (side === 'inside-top') {\n        top = anchorPosition.top + anchorOffset;\n    }\n    else if (side === 'inside-bottom') {\n        top = anchorBottom - anchorOffset - elementDimensions.height;\n    }\n    else if (side === 'inside-left') {\n        left = anchorPosition.left + anchorOffset;\n    }\n    else if (side === 'inside-right') {\n        left = anchorRight - anchorOffset - elementDimensions.width;\n    }\n    else if (side === 'inside-center') {\n        left = (anchorRight + anchorPosition.left) / 2 - elementDimensions.width / 2 + anchorOffset;\n    }\n    if (side === 'inside-top' || side === 'inside-bottom') {\n        if (align === 'start') {\n            left = anchorPosition.left + alignmentOffset;\n        }\n        else if (align === 'center') {\n            left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n        }\n        else {\n            left = anchorRight - elementDimensions.width - alignmentOffset;\n        }\n    }\n    else if (side === 'inside-left' || side === 'inside-right' || side === 'inside-center') {\n        if (align === 'start') {\n            top = anchorPosition.top + alignmentOffset;\n        }\n        else if (align === 'center') {\n            top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n        }\n        else {\n            top = anchorBottom - elementDimensions.height - alignmentOffset;\n        }\n    }\n    return { top, left };\n}\nfunction shouldRecalculatePosition(side, currentPos, containerDimensions, elementDimensions) {\n    if (side === 'outside-top' || side === 'outside-bottom') {\n        return (currentPos.top < containerDimensions.top ||\n            currentPos.top + elementDimensions.height > containerDimensions.height + containerDimensions.top);\n    }\n    else {\n        return (currentPos.left < containerDimensions.left ||\n            currentPos.left + elementDimensions.width > containerDimensions.width + containerDimensions.left);\n    }\n}\nfunction shouldRecalculateAlignment(align, currentPos, containerDimensions, elementDimensions) {\n    if (align === 'end') {\n        return currentPos.left < containerDimensions.left;\n    }\n    else if (align === 'start' || align === 'center') {\n        return (currentPos.left + elementDimensions.width > containerDimensions.left + containerDimensions.width ||\n            currentPos.left < containerDimensions.left);\n    }\n}\n\nexport { getAnchoredPosition };\n","import { polyfill } from './polyfills/event-listener-signal.mjs';\nimport { isMacOS } from './utils/user-agent.mjs';\nimport { iterateFocusableElements } from './utils/iterate-focusable-elements.mjs';\nimport { uniqueId } from './utils/unique-id.mjs';\n\npolyfill();\nvar FocusKeys;\n(function (FocusKeys) {\n    FocusKeys[FocusKeys[\"ArrowHorizontal\"] = 1] = \"ArrowHorizontal\";\n    FocusKeys[FocusKeys[\"ArrowVertical\"] = 2] = \"ArrowVertical\";\n    FocusKeys[FocusKeys[\"JK\"] = 4] = \"JK\";\n    FocusKeys[FocusKeys[\"HL\"] = 8] = \"HL\";\n    FocusKeys[FocusKeys[\"HomeAndEnd\"] = 16] = \"HomeAndEnd\";\n    FocusKeys[FocusKeys[\"PageUpDown\"] = 256] = \"PageUpDown\";\n    FocusKeys[FocusKeys[\"WS\"] = 32] = \"WS\";\n    FocusKeys[FocusKeys[\"AD\"] = 64] = \"AD\";\n    FocusKeys[FocusKeys[\"Tab\"] = 128] = \"Tab\";\n    FocusKeys[FocusKeys[\"Backspace\"] = 512] = \"Backspace\";\n    FocusKeys[FocusKeys[\"ArrowAll\"] = 3] = \"ArrowAll\";\n    FocusKeys[FocusKeys[\"HJKL\"] = 12] = \"HJKL\";\n    FocusKeys[FocusKeys[\"WASD\"] = 96] = \"WASD\";\n    FocusKeys[FocusKeys[\"All\"] = 511] = \"All\";\n})(FocusKeys || (FocusKeys = {}));\nconst KEY_TO_BIT = {\n    ArrowLeft: FocusKeys.ArrowHorizontal,\n    ArrowDown: FocusKeys.ArrowVertical,\n    ArrowUp: FocusKeys.ArrowVertical,\n    ArrowRight: FocusKeys.ArrowHorizontal,\n    h: FocusKeys.HL,\n    j: FocusKeys.JK,\n    k: FocusKeys.JK,\n    l: FocusKeys.HL,\n    a: FocusKeys.AD,\n    s: FocusKeys.WS,\n    w: FocusKeys.WS,\n    d: FocusKeys.AD,\n    Tab: FocusKeys.Tab,\n    Home: FocusKeys.HomeAndEnd,\n    End: FocusKeys.HomeAndEnd,\n    PageUp: FocusKeys.PageUpDown,\n    PageDown: FocusKeys.PageUpDown,\n    Backspace: FocusKeys.Backspace,\n};\nconst KEY_TO_DIRECTION = {\n    ArrowLeft: 'previous',\n    ArrowDown: 'next',\n    ArrowUp: 'previous',\n    ArrowRight: 'next',\n    h: 'previous',\n    j: 'next',\n    k: 'previous',\n    l: 'next',\n    a: 'previous',\n    s: 'next',\n    w: 'previous',\n    d: 'next',\n    Tab: 'next',\n    Home: 'start',\n    End: 'end',\n    PageUp: 'start',\n    PageDown: 'end',\n    Backspace: 'previous',\n};\nfunction getDirection(keyboardEvent) {\n    const direction = KEY_TO_DIRECTION[keyboardEvent.key];\n    if (keyboardEvent.key === 'Tab' && keyboardEvent.shiftKey) {\n        return 'previous';\n    }\n    const isMac = isMacOS();\n    if ((isMac && keyboardEvent.metaKey) || (!isMac && keyboardEvent.ctrlKey)) {\n        if (keyboardEvent.key === 'ArrowLeft' || keyboardEvent.key === 'ArrowUp') {\n            return 'start';\n        }\n        else if (keyboardEvent.key === 'ArrowRight' || keyboardEvent.key === 'ArrowDown') {\n            return 'end';\n        }\n    }\n    return direction;\n}\nfunction shouldIgnoreFocusHandling(keyboardEvent, activeElement) {\n    const key = keyboardEvent.key;\n    const keyLength = [...key].length;\n    const isTextInput = (activeElement instanceof HTMLInputElement && activeElement.type === 'text') ||\n        activeElement instanceof HTMLTextAreaElement;\n    if (isTextInput && (keyLength === 1 || key === 'Home' || key === 'End')) {\n        return true;\n    }\n    if (activeElement instanceof HTMLSelectElement) {\n        if (keyLength === 1) {\n            return true;\n        }\n        if (key === 'ArrowDown' && isMacOS() && !keyboardEvent.metaKey) {\n            return true;\n        }\n        if (key === 'ArrowDown' && !isMacOS() && keyboardEvent.altKey) {\n            return true;\n        }\n    }\n    if (activeElement instanceof HTMLTextAreaElement && (key === 'PageUp' || key === 'PageDown')) {\n        return true;\n    }\n    if (isTextInput) {\n        const textInput = activeElement;\n        const cursorAtStart = textInput.selectionStart === 0 && textInput.selectionEnd === 0;\n        const cursorAtEnd = textInput.selectionStart === textInput.value.length && textInput.selectionEnd === textInput.value.length;\n        if (key === 'ArrowLeft' && !cursorAtStart) {\n            return true;\n        }\n        if (key === 'ArrowRight' && !cursorAtEnd) {\n            return true;\n        }\n        if (textInput instanceof HTMLTextAreaElement) {\n            if (key === 'ArrowUp' && !cursorAtStart) {\n                return true;\n            }\n            if (key === 'ArrowDown' && !cursorAtEnd) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nconst isActiveDescendantAttribute = 'data-is-active-descendant';\nconst activeDescendantActivatedDirectly = 'activated-directly';\nconst activeDescendantActivatedIndirectly = 'activated-indirectly';\nconst hasActiveDescendantAttribute = 'data-has-active-descendant';\nfunction focusZone(container, settings) {\n    var _a, _b, _c, _d, _e;\n    const focusableElements = [];\n    const savedTabIndex = new WeakMap();\n    const bindKeys = (_a = settings === null || settings === void 0 ? void 0 : settings.bindKeys) !== null && _a !== void 0 ? _a : ((settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) ? FocusKeys.ArrowAll : FocusKeys.ArrowVertical) | FocusKeys.HomeAndEnd;\n    const focusOutBehavior = (_b = settings === null || settings === void 0 ? void 0 : settings.focusOutBehavior) !== null && _b !== void 0 ? _b : 'stop';\n    const focusInStrategy = (_c = settings === null || settings === void 0 ? void 0 : settings.focusInStrategy) !== null && _c !== void 0 ? _c : 'previous';\n    const activeDescendantControl = settings === null || settings === void 0 ? void 0 : settings.activeDescendantControl;\n    const activeDescendantCallback = settings === null || settings === void 0 ? void 0 : settings.onActiveDescendantChanged;\n    let currentFocusedElement;\n    const preventScroll = (_d = settings === null || settings === void 0 ? void 0 : settings.preventScroll) !== null && _d !== void 0 ? _d : false;\n    function getFirstFocusableElement() {\n        return focusableElements[0];\n    }\n    function isActiveDescendantInputFocused() {\n        return document.activeElement === activeDescendantControl;\n    }\n    function updateFocusedElement(to, directlyActivated = false) {\n        const from = currentFocusedElement;\n        currentFocusedElement = to;\n        if (activeDescendantControl) {\n            if (to && isActiveDescendantInputFocused()) {\n                setActiveDescendant(from, to, directlyActivated);\n            }\n            else {\n                clearActiveDescendant();\n            }\n            return;\n        }\n        if (from && from !== to && savedTabIndex.has(from)) {\n            from.setAttribute('tabindex', '-1');\n        }\n        to === null || to === void 0 ? void 0 : to.setAttribute('tabindex', '0');\n    }\n    function setActiveDescendant(from, to, directlyActivated = false) {\n        if (!to.id) {\n            to.setAttribute('id', uniqueId());\n        }\n        if (from && from !== to) {\n            from.removeAttribute(isActiveDescendantAttribute);\n        }\n        if (!activeDescendantControl ||\n            (!directlyActivated && activeDescendantControl.getAttribute('aria-activedescendant') === to.id)) {\n            return;\n        }\n        activeDescendantControl.setAttribute('aria-activedescendant', to.id);\n        container.setAttribute(hasActiveDescendantAttribute, to.id);\n        to.setAttribute(isActiveDescendantAttribute, directlyActivated ? activeDescendantActivatedDirectly : activeDescendantActivatedIndirectly);\n        activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(to, from, directlyActivated);\n    }\n    function clearActiveDescendant(previouslyActiveElement = currentFocusedElement) {\n        if (focusInStrategy === 'first') {\n            currentFocusedElement = undefined;\n        }\n        activeDescendantControl === null || activeDescendantControl === void 0 ? void 0 : activeDescendantControl.removeAttribute('aria-activedescendant');\n        container.removeAttribute(hasActiveDescendantAttribute);\n        previouslyActiveElement === null || previouslyActiveElement === void 0 ? void 0 : previouslyActiveElement.removeAttribute(isActiveDescendantAttribute);\n        activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(undefined, previouslyActiveElement, false);\n    }\n    function beginFocusManagement(...elements) {\n        const filteredElements = elements.filter(e => { var _a, _b; return (_b = (_a = settings === null || settings === void 0 ? void 0 : settings.focusableElementFilter) === null || _a === void 0 ? void 0 : _a.call(settings, e)) !== null && _b !== void 0 ? _b : true; });\n        if (filteredElements.length === 0) {\n            return;\n        }\n        focusableElements.splice(findInsertionIndex(filteredElements), 0, ...filteredElements);\n        for (const element of filteredElements) {\n            if (!savedTabIndex.has(element)) {\n                savedTabIndex.set(element, element.getAttribute('tabindex'));\n            }\n            element.setAttribute('tabindex', '-1');\n        }\n        if (!currentFocusedElement) {\n            updateFocusedElement(getFirstFocusableElement());\n        }\n    }\n    function findInsertionIndex(elementsToInsert) {\n        const firstElementToInsert = elementsToInsert[0];\n        if (focusableElements.length === 0)\n            return 0;\n        let iMin = 0;\n        let iMax = focusableElements.length - 1;\n        while (iMin <= iMax) {\n            const i = Math.floor((iMin + iMax) / 2);\n            const element = focusableElements[i];\n            if (followsInDocument(firstElementToInsert, element)) {\n                iMax = i - 1;\n            }\n            else {\n                iMin = i + 1;\n            }\n        }\n        return iMin;\n    }\n    function followsInDocument(first, second) {\n        return (second.compareDocumentPosition(first) & Node.DOCUMENT_POSITION_PRECEDING) > 0;\n    }\n    function endFocusManagement(...elements) {\n        for (const element of elements) {\n            const focusableElementIndex = focusableElements.indexOf(element);\n            if (focusableElementIndex >= 0) {\n                focusableElements.splice(focusableElementIndex, 1);\n            }\n            const savedIndex = savedTabIndex.get(element);\n            if (savedIndex !== undefined) {\n                if (savedIndex === null) {\n                    element.removeAttribute('tabindex');\n                }\n                else {\n                    element.setAttribute('tabindex', savedIndex);\n                }\n                savedTabIndex.delete(element);\n            }\n            if (element === currentFocusedElement) {\n                const nextElementToFocus = getFirstFocusableElement();\n                updateFocusedElement(nextElementToFocus);\n            }\n        }\n    }\n    const iterateFocusableElementsOptions = {\n        reverse: settings === null || settings === void 0 ? void 0 : settings.reverse,\n        strict: settings === null || settings === void 0 ? void 0 : settings.strict,\n        onlyTabbable: settings === null || settings === void 0 ? void 0 : settings.onlyTabbable,\n    };\n    beginFocusManagement(...iterateFocusableElements(container, iterateFocusableElementsOptions));\n    const initialElement = typeof focusInStrategy === 'function' ? focusInStrategy(document.body) : getFirstFocusableElement();\n    updateFocusedElement(initialElement);\n    const observer = new MutationObserver(mutations => {\n        for (const mutation of mutations) {\n            for (const removedNode of mutation.removedNodes) {\n                if (removedNode instanceof HTMLElement) {\n                    endFocusManagement(...iterateFocusableElements(removedNode));\n                }\n            }\n            if (mutation.type === 'attributes' && mutation.oldValue === null) {\n                if (mutation.target instanceof HTMLElement) {\n                    endFocusManagement(mutation.target);\n                }\n            }\n        }\n        for (const mutation of mutations) {\n            for (const addedNode of mutation.addedNodes) {\n                if (addedNode instanceof HTMLElement) {\n                    beginFocusManagement(...iterateFocusableElements(addedNode, iterateFocusableElementsOptions));\n                }\n            }\n            if (mutation.type === 'attributes' && mutation.oldValue !== null) {\n                if (mutation.target instanceof HTMLElement) {\n                    beginFocusManagement(mutation.target);\n                }\n            }\n        }\n    });\n    observer.observe(container, {\n        subtree: true,\n        childList: true,\n        attributeFilter: ['hidden', 'disabled'],\n        attributeOldValue: true,\n    });\n    const controller = new AbortController();\n    const signal = (_e = settings === null || settings === void 0 ? void 0 : settings.abortSignal) !== null && _e !== void 0 ? _e : controller.signal;\n    signal.addEventListener('abort', () => {\n        endFocusManagement(...focusableElements);\n    });\n    let elementIndexFocusedByClick = undefined;\n    container.addEventListener('mousedown', event => {\n        if (event.target instanceof HTMLElement && event.target !== document.activeElement) {\n            elementIndexFocusedByClick = focusableElements.indexOf(event.target);\n        }\n    }, { signal });\n    if (activeDescendantControl) {\n        container.addEventListener('focusin', event => {\n            if (event.target instanceof HTMLElement && focusableElements.includes(event.target)) {\n                activeDescendantControl.focus({ preventScroll });\n                updateFocusedElement(event.target);\n            }\n        });\n        container.addEventListener('mousemove', ({ target }) => {\n            if (!(target instanceof Node)) {\n                return;\n            }\n            const focusableElement = focusableElements.find(element => element.contains(target));\n            if (focusableElement) {\n                updateFocusedElement(focusableElement);\n            }\n        }, { signal, capture: true });\n        activeDescendantControl.addEventListener('focusin', () => {\n            if (!currentFocusedElement) {\n                updateFocusedElement(getFirstFocusableElement());\n            }\n            else {\n                setActiveDescendant(undefined, currentFocusedElement);\n            }\n        });\n        activeDescendantControl.addEventListener('focusout', () => {\n            clearActiveDescendant();\n        });\n    }\n    else {\n        container.addEventListener('focusin', event => {\n            if (event.target instanceof HTMLElement) {\n                if (elementIndexFocusedByClick !== undefined) {\n                    if (elementIndexFocusedByClick >= 0) {\n                        if (focusableElements[elementIndexFocusedByClick] !== currentFocusedElement) {\n                            updateFocusedElement(focusableElements[elementIndexFocusedByClick]);\n                        }\n                    }\n                    elementIndexFocusedByClick = undefined;\n                }\n                else {\n                    if (focusInStrategy === 'previous') {\n                        updateFocusedElement(event.target);\n                    }\n                    else if (focusInStrategy === 'closest' || focusInStrategy === 'first') {\n                        if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n                            const targetElementIndex = lastKeyboardFocusDirection === 'previous' ? focusableElements.length - 1 : 0;\n                            const targetElement = focusableElements[targetElementIndex];\n                            targetElement === null || targetElement === void 0 ? void 0 : targetElement.focus({ preventScroll });\n                            return;\n                        }\n                        else {\n                            updateFocusedElement(event.target);\n                        }\n                    }\n                    else if (typeof focusInStrategy === 'function') {\n                        if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n                            const elementToFocus = focusInStrategy(event.relatedTarget);\n                            const requestedFocusElementIndex = elementToFocus ? focusableElements.indexOf(elementToFocus) : -1;\n                            if (requestedFocusElementIndex >= 0 && elementToFocus instanceof HTMLElement) {\n                                elementToFocus.focus({ preventScroll });\n                                return;\n                            }\n                            else {\n                                console.warn('Element requested is not a known focusable element.');\n                            }\n                        }\n                        else {\n                            updateFocusedElement(event.target);\n                        }\n                    }\n                }\n            }\n            lastKeyboardFocusDirection = undefined;\n        }, { signal });\n    }\n    const keyboardEventRecipient = activeDescendantControl !== null && activeDescendantControl !== void 0 ? activeDescendantControl : container;\n    let lastKeyboardFocusDirection = undefined;\n    if (focusInStrategy === 'closest') {\n        document.addEventListener('keydown', event => {\n            if (event.key === 'Tab') {\n                lastKeyboardFocusDirection = getDirection(event);\n            }\n        }, { signal, capture: true });\n    }\n    function getCurrentFocusedIndex() {\n        if (!currentFocusedElement) {\n            return 0;\n        }\n        const focusedIndex = focusableElements.indexOf(currentFocusedElement);\n        const fallbackIndex = currentFocusedElement === container ? -1 : 0;\n        return focusedIndex !== -1 ? focusedIndex : fallbackIndex;\n    }\n    keyboardEventRecipient.addEventListener('keydown', event => {\n        var _a;\n        if (event.key in KEY_TO_DIRECTION) {\n            const keyBit = KEY_TO_BIT[event.key];\n            if (!event.defaultPrevented &&\n                (keyBit & bindKeys) > 0 &&\n                !shouldIgnoreFocusHandling(event, document.activeElement)) {\n                const direction = getDirection(event);\n                let nextElementToFocus = undefined;\n                if (settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) {\n                    nextElementToFocus = settings.getNextFocusable(direction, (_a = document.activeElement) !== null && _a !== void 0 ? _a : undefined, event);\n                }\n                if (!nextElementToFocus) {\n                    const lastFocusedIndex = getCurrentFocusedIndex();\n                    let nextFocusedIndex = lastFocusedIndex;\n                    if (direction === 'previous') {\n                        nextFocusedIndex -= 1;\n                    }\n                    else if (direction === 'start') {\n                        nextFocusedIndex = 0;\n                    }\n                    else if (direction === 'next') {\n                        nextFocusedIndex += 1;\n                    }\n                    else {\n                        nextFocusedIndex = focusableElements.length - 1;\n                    }\n                    if (nextFocusedIndex < 0) {\n                        if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n                            nextFocusedIndex = focusableElements.length - 1;\n                        }\n                        else {\n                            nextFocusedIndex = 0;\n                        }\n                    }\n                    if (nextFocusedIndex >= focusableElements.length) {\n                        if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n                            nextFocusedIndex = 0;\n                        }\n                        else {\n                            nextFocusedIndex = focusableElements.length - 1;\n                        }\n                    }\n                    if (lastFocusedIndex !== nextFocusedIndex) {\n                        nextElementToFocus = focusableElements[nextFocusedIndex];\n                    }\n                }\n                if (activeDescendantControl) {\n                    updateFocusedElement(nextElementToFocus || currentFocusedElement, true);\n                }\n                else if (nextElementToFocus) {\n                    lastKeyboardFocusDirection = direction;\n                    nextElementToFocus.focus({ preventScroll });\n                }\n                if (event.key !== 'Tab' || nextElementToFocus) {\n                    event.preventDefault();\n                }\n            }\n        }\n    }, { signal });\n    return controller;\n}\n\nexport { FocusKeys, activeDescendantActivatedDirectly, activeDescendantActivatedIndirectly, focusZone, hasActiveDescendantAttribute, isActiveDescendantAttribute };\n","let signalSupported = false;\nfunction noop() { }\ntry {\n    const options = Object.create({}, {\n        signal: {\n            get() {\n                signalSupported = true;\n            },\n        },\n    });\n    window.addEventListener('test', noop, options);\n    window.removeEventListener('test', noop, options);\n}\ncatch (e) {\n}\nfunction featureSupported() {\n    return signalSupported;\n}\nfunction monkeyPatch() {\n    if (typeof window === 'undefined') {\n        return;\n    }\n    const originalAddEventListener = EventTarget.prototype.addEventListener;\n    EventTarget.prototype.addEventListener = function (name, originalCallback, optionsOrCapture) {\n        if (typeof optionsOrCapture === 'object' &&\n            'signal' in optionsOrCapture &&\n            optionsOrCapture.signal instanceof AbortSignal) {\n            originalAddEventListener.call(optionsOrCapture.signal, 'abort', () => {\n                this.removeEventListener(name, originalCallback, optionsOrCapture);\n            });\n        }\n        return originalAddEventListener.call(this, name, originalCallback, optionsOrCapture);\n    };\n}\nfunction polyfill() {\n    if (!featureSupported()) {\n        monkeyPatch();\n        signalSupported = true;\n    }\n}\n\nexport { polyfill };\n","let idSeed = 10000;\nfunction uniqueId() {\n    return `__primer_id_${idSeed++}`;\n}\n\nexport { uniqueId };\n","function scrollIntoView(child, viewingArea, { direction = 'vertical', startMargin = 0, endMargin = 0, behavior = 'smooth' } = {}) {\n    const startSide = direction === 'vertical' ? 'top' : 'left';\n    const endSide = direction === 'vertical' ? 'bottom' : 'right';\n    const scrollSide = direction === 'vertical' ? 'scrollTop' : 'scrollLeft';\n    const { [startSide]: childStart, [endSide]: childEnd } = child.getBoundingClientRect();\n    const { [startSide]: viewingAreaStart, [endSide]: viewingAreaEnd } = viewingArea.getBoundingClientRect();\n    const isChildStartAboveViewingArea = childStart < viewingAreaStart + startMargin;\n    const isChildBottomBelowViewingArea = childEnd > viewingAreaEnd - endMargin;\n    if (isChildStartAboveViewingArea) {\n        const scrollHeightToChildStart = childStart - viewingAreaStart + viewingArea[scrollSide];\n        viewingArea.scrollTo({ behavior, [startSide]: scrollHeightToChildStart - startMargin });\n    }\n    else if (isChildBottomBelowViewingArea) {\n        const scrollHeightToChildBottom = childEnd - viewingAreaEnd + viewingArea[scrollSide];\n        viewingArea.scrollTo({ behavior, [startSide]: scrollHeightToChildBottom + endMargin });\n    }\n}\n\nexport { scrollIntoView };\n","function offset(element) {\n    const rect = element.getBoundingClientRect();\n    return {\n        top: rect.top + window.pageYOffset,\n        left: rect.left + window.pageXOffset,\n    };\n}\nfunction overflowParent(targetElement) {\n    let element = targetElement;\n    const document = element.ownerDocument;\n    if (!document) {\n        return;\n    }\n    if (!element.offsetParent) {\n        return;\n    }\n    const HTMLElement = document.defaultView.HTMLElement;\n    if (element === document.body) {\n        return;\n    }\n    while (element !== document.body) {\n        if (element.parentElement instanceof HTMLElement) {\n            element = element.parentElement;\n        }\n        else {\n            return;\n        }\n        const { position, overflowY, overflowX } = getComputedStyle(element);\n        if (position === 'fixed' ||\n            overflowY === 'auto' ||\n            overflowX === 'auto' ||\n            overflowY === 'scroll' ||\n            overflowX === 'scroll') {\n            break;\n        }\n    }\n    return element instanceof Document ? null : element;\n}\nfunction overflowOffset(element, targetContainer) {\n    let container = targetContainer;\n    const document = element.ownerDocument;\n    if (!document) {\n        return;\n    }\n    const documentElement = document.documentElement;\n    if (!documentElement) {\n        return;\n    }\n    if (element === documentElement) {\n        return;\n    }\n    const elementOffset = positionedOffset(element, container);\n    if (!elementOffset) {\n        return;\n    }\n    container = elementOffset._container;\n    const scroll = container === document.documentElement && document.defaultView\n        ? {\n            top: document.defaultView.pageYOffset,\n            left: document.defaultView.pageXOffset,\n        }\n        : {\n            top: container.scrollTop,\n            left: container.scrollLeft,\n        };\n    const top = elementOffset.top - scroll.top;\n    const left = elementOffset.left - scroll.left;\n    const height = container.clientHeight;\n    const width = container.clientWidth;\n    const bottom = height - (top + element.offsetHeight);\n    const right = width - (left + element.offsetWidth);\n    return { top, left, bottom, right, height, width };\n}\nfunction positionedOffset(targetElement, container) {\n    let element = targetElement;\n    const document = element.ownerDocument;\n    if (!document) {\n        return;\n    }\n    const documentElement = document.documentElement;\n    if (!documentElement) {\n        return;\n    }\n    const HTMLElement = document.defaultView.HTMLElement;\n    let top = 0;\n    let left = 0;\n    const height = element.offsetHeight;\n    const width = element.offsetWidth;\n    while (!(element === document.body || element === container)) {\n        top += element.offsetTop || 0;\n        left += element.offsetLeft || 0;\n        if (element.offsetParent instanceof HTMLElement) {\n            element = element.offsetParent;\n        }\n        else {\n            return;\n        }\n    }\n    let scrollHeight;\n    let scrollWidth;\n    let measuredContainer;\n    if (!container ||\n        container === document ||\n        container === document.defaultView ||\n        container === document.documentElement ||\n        container === document.body) {\n        measuredContainer = documentElement;\n        scrollHeight = getDocumentHeight(document.body, documentElement);\n        scrollWidth = getDocumentWidth(document.body, documentElement);\n    }\n    else if (container instanceof HTMLElement) {\n        measuredContainer = container;\n        scrollHeight = container.scrollHeight;\n        scrollWidth = container.scrollWidth;\n    }\n    else {\n        return;\n    }\n    const bottom = scrollHeight - (top + height);\n    const right = scrollWidth - (left + width);\n    return { top, left, bottom, right, _container: measuredContainer };\n}\nfunction getDocumentHeight(documentBody, documentElement) {\n    return Math.max(documentBody.scrollHeight, documentElement.scrollHeight, documentBody.offsetHeight, documentElement.offsetHeight, documentElement.clientHeight);\n}\nfunction getDocumentWidth(documentBody, documentElement) {\n    return Math.max(documentBody.scrollWidth, documentElement.scrollWidth, documentBody.offsetWidth, documentElement.offsetWidth, documentElement.clientWidth);\n}\n\nexport { offset, overflowOffset, overflowParent, positionedOffset };\n","function* iterateFocusableElements(container, options = {}) {\n    var _a, _b;\n    const strict = (_a = options.strict) !== null && _a !== void 0 ? _a : false;\n    const acceptFn = ((_b = options.onlyTabbable) !== null && _b !== void 0 ? _b : false) ? isTabbable : isFocusable;\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n        acceptNode: node => node instanceof HTMLElement && acceptFn(node, strict) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP,\n    });\n    let nextNode = null;\n    if (!options.reverse && acceptFn(container, strict)) {\n        yield container;\n    }\n    if (options.reverse) {\n        let lastChild = walker.lastChild();\n        while (lastChild) {\n            nextNode = lastChild;\n            lastChild = walker.lastChild();\n        }\n    }\n    else {\n        nextNode = walker.firstChild();\n    }\n    while (nextNode instanceof HTMLElement) {\n        yield nextNode;\n        nextNode = options.reverse ? walker.previousNode() : walker.nextNode();\n    }\n    if (options.reverse && acceptFn(container, strict)) {\n        yield container;\n    }\n    return undefined;\n}\nfunction getFocusableChild(container, lastChild = false) {\n    return iterateFocusableElements(container, { reverse: lastChild, strict: true, onlyTabbable: true }).next().value;\n}\nfunction isFocusable(elem, strict = false) {\n    const disabledAttrInert = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(elem.tagName) &&\n        elem.disabled;\n    const hiddenInert = elem.hidden;\n    const hiddenInputInert = elem instanceof HTMLInputElement && elem.type === 'hidden';\n    const sentinelInert = elem.classList.contains('sentinel');\n    if (disabledAttrInert || hiddenInert || hiddenInputInert || sentinelInert) {\n        return false;\n    }\n    if (strict) {\n        const style = getComputedStyle(elem);\n        const sizeInert = elem.offsetWidth === 0 || elem.offsetHeight === 0;\n        const visibilityInert = ['hidden', 'collapse'].includes(style.visibility);\n        const displayInert = style.display === 'none' || !elem.offsetParent;\n        const clientRectsInert = elem.getClientRects().length === 0;\n        if (sizeInert || visibilityInert || clientRectsInert || displayInert) {\n            return false;\n        }\n    }\n    if (elem.getAttribute('tabindex') != null) {\n        return true;\n    }\n    if (elem.getAttribute('contenteditable') === 'true' || elem.getAttribute('contenteditable') === 'plaintext-only') {\n        return true;\n    }\n    if (elem instanceof HTMLAnchorElement && elem.getAttribute('href') == null) {\n        return false;\n    }\n    return elem.tabIndex !== -1;\n}\nfunction isTabbable(elem, strict = false) {\n    return isFocusable(elem, strict) && elem.getAttribute('tabindex') !== '-1';\n}\n\nexport { getFocusableChild, isFocusable, isTabbable, iterateFocusableElements };\n","let isMac = undefined;\nfunction isMacOS() {\n    if (isMac === undefined) {\n        isMac = /^mac/i.test(window.navigator.platform);\n    }\n    return isMac;\n}\n\nexport { isMacOS };\n"],"names":["activeTrap","focusTrap","container","initialFocus","abortSignal","lastFocusedChild","controller","AbortController","signal","setAttribute","sentinelStart","document","createElement","onfocus","lastFocusableChild","focus","sentinelEnd","firstFocusableChild","prepend","append","observer","observeFocusTrap","sentinels","MutationObserver","mutations","mutation","type","addedNodes","length","sentinelChildren","from","filter","e","HTMLElement","classList","contains","tagName","firstChild","firstElementChild","lastChild","lastElementChild","insertAdjacentElement","observe","childList","ensureTrapZoneHasFocus","focusedElement","wrappingController","followSignal","addEventListener","abort","suspendedTrap","suspendedTrapStack","push","undefined","removeAttribute","getElementsByClassName","remove","suspendedTrapIndex","findIndex","t","splice","disconnect","tryReactivate","trapToReactivate","pop","originalSignal","event","target","capture","activeElement","alternateOrders","alternateAlignments","start","end","center","getAnchoredPosition","floatingElement","anchorElement","settings","parentElement","getPositionedParent","element","isOnTopLayer","_a","matches","test","body","showPopover","toString","_b","parentNode","getComputedStyle","position","clippingRect","getClippingRect","Element","parentNodeStyle","overflow","clippingNode","elemRect","getBoundingClientRect","elemStyle","borderTop","borderLeft","borderRight","borderBottom","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","map","v","parseInt","top","left","width","height","Math","max","window","innerHeight","Infinity","parentElementStyle","parentElementRect","pureCalculateAnchoredPosition","viewportRect","relativePosition","floatingRect","anchorRect","side","align","allowOutOfBounds","anchorOffset","alignmentOffset","relativeViewportRect","pos","calculatePosition","anchorSide","anchorAlign","currentPos","alternateOrder","positionAttempt","prevSide","containerDimensions","elementDimensions","nextSide","alternateAlignment","alignmentAttempt","prevAlign","nextAlign","Object","assign","getDefaultSettings","_c","_d","_e","positionDefaults","startsWith","anchorPosition","anchorRight","anchorBottom","FocusKeys","signalSupported","noop","options","create","get","removeEventListener","polyfill","monkeyPatch","originalAddEventListener","EventTarget","prototype","name","originalCallback","optionsOrCapture","AbortSignal","call","idSeed","KEY_TO_BIT","ArrowLeft","ArrowHorizontal","ArrowDown","ArrowVertical","ArrowUp","ArrowRight","h","HL","j","JK","k","l","a","AD","s","WS","w","d","Tab","Home","HomeAndEnd","End","PageUp","PageUpDown","PageDown","Backspace","KEY_TO_DIRECTION","getDirection","keyboardEvent","direction","key","shiftKey","isMac","metaKey","ctrlKey","isActiveDescendantAttribute","activeDescendantActivatedDirectly","activeDescendantActivatedIndirectly","hasActiveDescendantAttribute","focusZone","currentFocusedElement","elementIndexFocusedByClick","lastKeyboardFocusDirection","focusableElements","savedTabIndex","WeakMap","bindKeys","getNextFocusable","ArrowAll","focusOutBehavior","focusInStrategy","activeDescendantControl","activeDescendantCallback","onActiveDescendantChanged","preventScroll","updateFocusedElement","to","directlyActivated","setActiveDescendant","clearActiveDescendant","has","id","getAttribute","previouslyActiveElement","beginFocusManagement","elements","filteredElements","focusableElementFilter","findInsertionIndex","elementsToInsert","firstElementToInsert","iMin","iMax","i","floor","second","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","set","endFocusManagement","focusableElementIndex","indexOf","savedIndex","delete","iterateFocusableElementsOptions","reverse","strict","onlyTabbable","removedNode","removedNodes","oldValue","addedNode","subtree","attributeFilter","attributeOldValue","includes","focusableElement","find","relatedTarget","targetElementIndex","targetElement","elementToFocus","requestedFocusElementIndex","console","warn","keyboardEventRecipient","keyBit","defaultPrevented","shouldIgnoreFocusHandling","keyLength","isTextInput","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","altKey","cursorAtStart","textInput","selectionStart","selectionEnd","cursorAtEnd","value","nextElementToFocus","lastFocusedIndex","getCurrentFocusedIndex","focusedIndex","fallbackIndex","nextFocusedIndex","preventDefault","scrollIntoView","child","viewingArea","startMargin","endMargin","behavior","startSide","endSide","scrollSide","childStart","childEnd","viewingAreaStart","viewingAreaEnd","scrollHeightToChildStart","scrollTo","scrollHeightToChildBottom","offset","rect","pageYOffset","pageXOffset","overflowParent","ownerDocument","offsetParent","defaultView","overflowY","overflowX","Document","overflowOffset","targetContainer","documentElement","elementOffset","positionedOffset","scroll","_container","scrollTop","scrollLeft","clientHeight","clientWidth","bottom","offsetHeight","right","offsetWidth","scrollHeight","scrollWidth","measuredContainer","offsetTop","offsetLeft","documentBody","iterateFocusableElements","acceptFn","isTabbable","isFocusable","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","FILTER_ACCEPT","FILTER_SKIP","nextNode","previousNode","getFocusableChild","next","elem","disabledAttrInert","disabled","hiddenInert","hidden","hiddenInputInert","sentinelInert","style","sizeInert","visibilityInert","visibility","displayInert","display","clientRectsInert","getClientRects","HTMLAnchorElement","tabIndex","isMacOS","navigator","platform"],"sourceRoot":""}