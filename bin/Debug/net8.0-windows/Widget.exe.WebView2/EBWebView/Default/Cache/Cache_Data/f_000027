{"version":3,"file":"ui_packages_updatable-content_updatable-content_ts-xxxxxxxxxxxx.js","mappings":"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","sources":["ui/packages/browser-history-state/browser-history-state.ts","ui/packages/form-utils/form-utils.ts","ui/packages/form-utils/remote-submit.ts","ui/packages/has-interactions/has-interactions.ts","ui/packages/morpheus/index.ts","ui/packages/parse-html/parse-html.ts","ui/packages/updatable-content/updatable-content.ts"],"sourcesContent":["import {ssrSafeWindow, ssrSafeHistory, ssrSafeLocation} from '@github-ui/ssr-utils'\n\nlet sessionHistoryEntries: Array<{url: string; state: unknown}> = []\nlet sessionHistoryOffset = 0\nlet state: State\n\ntype State = {\n  _id: number\n  turbo?: {\n    restorationIdentifier: string\n  }\n}\n\n/*\n * Array of history entries.\n *\n * Example:\n * {\n *   0: {\n *     url: \"/\",\n *     state: { ... }.\n *   },\n *   1: {\n *     url: \"/github/github/issues/123\",\n *     state: { ... }.\n *   },\n *   2: {\n *     url: \"/github/github/issues/123#comment-4\",\n *     state: { ... }.\n *   }.\n *  }.\n */\n\nexport function getState(): State {\n  return state\n}\n\nfunction safeGetHistory() {\n  try {\n    // Clamp history.length to 0<->9007199254740991 (Number.MAX_SAFE_INTEGER isn't supported in IE)\n    return Math.min(Math.max(0, ssrSafeHistory?.length || 0) || 0, 9007199254740991)\n  } catch {\n    return 0\n  }\n}\n\nfunction initializeState(): State {\n  const newState = {_id: Date.now(), ...ssrSafeHistory?.state}\n  setState(newState)\n  return newState\n}\n\n// Current index into history entries stack.\nfunction position(): number {\n  return safeGetHistory() - 1 + sessionHistoryOffset\n}\n\nfunction setState(newState: State) {\n  state = newState\n\n  // Update entry at current position\n  const url = ssrSafeLocation?.href\n  sessionHistoryEntries[position()] = {url, state}\n\n  // Trim entries to match history size\n  sessionHistoryEntries.length = safeGetHistory()\n\n  // Emit public statechange\n  ssrSafeWindow?.dispatchEvent(new CustomEvent('statechange', {bubbles: false, cancelable: false}))\n}\n\n// Generate unique id for state object.\n//\n// Use a timestamp instead of a counter since ids should still be unique\n// across page loads.\nfunction uniqueId(): number {\n  return Date.now()\n}\n\n// Indirection for history.pushState to support tracking URL changes.\n//\n// Would be great if there was a standard window.addEventListener('statechange') event.\nexport function pushState(oldState: State | null, title: string, url: string) {\n  // pushState drops any forward history entries\n  sessionHistoryOffset = 0\n  const newState = {_id: uniqueId(), ...oldState}\n  ssrSafeHistory?.pushState(newState, title, url)\n  setState(newState)\n}\n\n// Indirection for history.replaceState to support tracking URL changes.\n//\n// Would be great if there was a standard window.addEventListener('statechange') event.\nexport function replaceState(oldState: Record<string, unknown> | null, title: string, url: string) {\n  const newState = {...getState(), ...oldState}\n  ssrSafeHistory?.replaceState(newState, title, url)\n  setState(newState)\n}\n\nstate = initializeState()\n\nssrSafeWindow?.addEventListener(\n  'popstate',\n  function onPopstate(event: PopStateEvent) {\n    const currentState: State = event.state\n\n    if (!currentState || (!currentState._id && !currentState.turbo?.restorationIdentifier)) {\n      // Unmanaged state in history entries\n      // Or could be a hashchange pop, ignore and let hashchange handle it\n      return\n    }\n\n    // Each state has a unique restorationIdentifier provided by Turbo. We compare the id\n    // to see if we are going backwards or forwards.\n    const id = currentState.turbo?.restorationIdentifier\n    const restoreId = (sessionHistoryEntries[position() - 1]?.state as State)?.turbo?.restorationIdentifier\n\n    if (restoreId === id) {\n      sessionHistoryOffset--\n    } else {\n      sessionHistoryOffset++\n    }\n\n    setState(currentState)\n  },\n  true,\n)\n\nlet turboAction: string\n\nssrSafeWindow?.addEventListener('turbo:visit', event => {\n  if (!(event instanceof CustomEvent)) return\n\n  turboAction = event.detail.action\n})\n\n// Listen turbo navigations to reset the `sessionHistoryOffset` in case we are doing a page load\n// instead of poping a state from the history stack.\nssrSafeWindow?.addEventListener('turbo:load', () => {\n  if (turboAction === 'restore') return\n\n  sessionHistoryOffset = 0\n  // Add turbo navigations to the state stack, so we can keep it complete without `empty` entries.\n  replaceState(ssrSafeHistory?.state, '', '')\n})\n\nssrSafeWindow?.addEventListener(\n  'hashchange',\n  function onHashchange() {\n    if (safeGetHistory() > sessionHistoryEntries.length) {\n      // Forward navigation\n      const newState = {_id: uniqueId()}\n      ssrSafeHistory?.replaceState(newState, '', ssrSafeLocation.href)\n      setState(newState)\n    }\n  },\n  true,\n)\n\n// We need to reset our history state on full-page loads to prevent our state from getting out of sync with the browser's history stack.\nssrSafeWindow?.addEventListener('pageshow', () => {\n  sessionHistoryEntries = []\n  sessionHistoryOffset = 0\n})\n","import {persistSubmitButtonValue} from './remote-submit'\n\ntype TextField = HTMLInputElement | HTMLTextAreaElement\ntype Button = HTMLInputElement | HTMLButtonElement\n\nfunction fire(target: HTMLElement, name: string, cancelable: boolean): boolean {\n  return target.dispatchEvent(\n    new CustomEvent(name, {\n      bubbles: true,\n      cancelable,\n    }),\n  )\n}\n\n// Submit a form while ensuring that `submit` event is also triggered.\n//\n// Calling native `form.submit()` method immediately submits the form without triggering the `submit` event.\n// As a result, code that wants to hook into form submits would never execute.\n//\n// This method first triggers the `submit` event and, if that event wasn't `preventDefault`d, submits the\n// form natively.\nexport function requestSubmit(form: HTMLFormElement, submitter?: Button) {\n  if (submitter) {\n    checkButtonValidity(form, submitter)\n    persistSubmitButtonValue(submitter)\n  }\n  if (fire(form, 'submit', true)) {\n    form.submit()\n  }\n}\n\n// Check submitter validity for form.requestSubmit compatibility.\n// See https://html.spec.whatwg.org/#dom-form-requestsubmit.\nfunction checkButtonValidity(form: HTMLFormElement, submitter: Button) {\n  if (!(form instanceof HTMLFormElement)) throw new TypeError('The specified element is not of type HTMLFormElement.')\n  if (!(submitter instanceof HTMLElement)) throw new TypeError('The specified element is not of type HTMLElement.')\n  if (submitter.type !== 'submit') throw new TypeError('The specified element is not a submit button.')\n  if (!form || form !== submitter.form) throw new Error('The specified element is not owned by the form element.')\n}\n\n// Set a form field value while ensuring that `change` event is also triggered.\n//\n// Having the `change` event fire is important for various behaviors to react, such as form validation.\nexport function changeValue(input: TextField, value: string | boolean) {\n  if (typeof value === 'boolean') {\n    if (input instanceof HTMLInputElement) {\n      input.checked = value\n    } else {\n      throw new TypeError('only checkboxes can be set to boolean value')\n    }\n  } else {\n    if (input.type === 'checkbox') {\n      throw new TypeError(\"checkbox can't be set to string value\")\n    } else {\n      input.value = value\n    }\n  }\n  fire(input, 'change', false)\n}\n\n// Fill multiple form fields by item name.\nexport function fillFormValues(form: HTMLFormElement, fields: {[key: string]: string}) {\n  for (const name in fields) {\n    const value = fields[name]\n    const element = form.elements.namedItem(name)\n\n    if (element instanceof HTMLInputElement) {\n      element.value = value!\n    } else if (element instanceof HTMLTextAreaElement) {\n      element.value = value!\n    }\n  }\n}\n\n// Test if element is a form field.\nexport function isFormField(element: Node): boolean {\n  if (!(element instanceof HTMLElement)) {\n    return false\n  }\n\n  const name = element.nodeName.toLowerCase()\n  const type = (element.getAttribute('type') || '').toLowerCase()\n  return (\n    name === 'select' ||\n    name === 'textarea' ||\n    (name === 'input' && type !== 'submit' && type !== 'reset') ||\n    element.isContentEditable\n  )\n}\n\nfunction searchParamsFromFormData(formData: FormData): URLSearchParams {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return new URLSearchParams(formData as any)\n}\n\n// Get a `?` search string for a URL for a GET form, using its `action` attribute as well as its other fields.\nexport function combineGetFormSearchParams(formAction: URL, formData: FormData): string {\n  const allSearchParams = new URLSearchParams(formAction.search)\n  const searchParamsFromInputs = searchParamsFromFormData(formData)\n  for (const [key, value] of searchParamsFromInputs) {\n    allSearchParams.append(key, value)\n  }\n  return allSearchParams.toString()\n}\n\n// Serialize form data into string.\nexport function serialize(form: HTMLFormElement): string {\n  return searchParamsFromFormData(new FormData(form)).toString()\n}\n","// Emulates submit button submission values by inserting a hidden input to the form.\n//\n// Submit events can be triggerd in the following ways:\n// - User clicks on a submit button.\n// - User press Enter when focusing on a form field; also known as \"implicit submission\".\n// - Programmatically via requestSubmit helper.\n//\n// On GitHub.com, the submission is either handled by the browser or remoteForm.\n//\n// For submissions triggered by user actions, the name and value of the clicked submit button (also known as\n// \"the submitter\") is passed along in the request, and can be programmatically retrieved with FormData.entries().\n//\n// However, this value will be lost in the following cases:\n// - 1. When the submitter button is disabled, most commonly by [data-disable-with].\n// - 2. When submitting via requestSubmit (from form.js), because the submission does not originated from a submitter.\n// - 3. When submitting with remoteForm, because FormData(form).entries() does not know about the submitter. In Safari\n// the submitter is known during the submission steps, but this behavior is not supported in any other browsers.\n//\n// @see {@link https://github.com/github/form-data-entries/pull/7}.\n//\n// For the exact workarounds, refer to ./form.js and ./remote.js.\nexport function persistSubmitButtonValue(button: HTMLButtonElement | HTMLInputElement) {\n  const form = button.closest('form')\n  if (!(form instanceof HTMLFormElement)) {\n    return\n  }\n\n  let input = findPersistedSubmitButtonValue(form)\n\n  if (button.name) {\n    const defaultValue = button.matches('input[type=submit]') ? 'Submit' : ''\n    const value = button.value || defaultValue\n    if (!input) {\n      input = document.createElement('input')\n      input.type = 'hidden'\n      input.classList.add('js-submit-button-value')\n      form.prepend(input)\n    }\n    input.name = button.name\n    input.value = value\n  } else if (input) {\n    input.remove()\n  }\n}\n\nexport function findPersistedSubmitButtonValue(form: HTMLFormElement): HTMLInputElement | null {\n  const input = form.querySelector('input.js-submit-button-value')\n  return input instanceof HTMLInputElement ? input : null\n}\n","import DetailsDialogElement from '@github/details-dialog-element'\nimport {isFormField} from '@github-ui/form-utils'\nimport {ssrSafeDocument} from '@github-ui/ssr-utils'\n\n// Check if container has any user interactions that could be lost if replaced.\n//\n// container - An Element to check for user interactions.\n// ignoreFocusedContainer - A Boolean, `true` to skip the\n// focus check if the container is the focused element. Dirty field and\n// mousedown checks are still performed.\nexport function hasInteractions(\n  container: Element,\n  ignoreFocusedContainer = false,\n  ignoreDirtyFields = false,\n): boolean {\n  return (\n    (!ignoreDirtyFields && hasDirtyFields(container)) ||\n    hasFocus(container, ignoreFocusedContainer) ||\n    hasMousedown(container) ||\n    markedAsDirty(container)\n  )\n}\n\nexport function hasDirtyFields(container: Element): boolean {\n  for (const field of container.querySelectorAll('input, textarea')) {\n    if (field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement) {\n      if (formFieldValueChanged(field)) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction formFieldValueChanged(input: HTMLInputElement | HTMLTextAreaElement): boolean {\n  if (input instanceof HTMLInputElement && (input.type === 'checkbox' || input.type === 'radio')) {\n    if (input.checked !== input.defaultChecked) return true\n  } else {\n    if (input.value !== input.defaultValue) return true\n  }\n  return false\n}\n\nlet stubbedActiveElement: Element | null\n\nexport async function withActiveElement(element: Element, fn: () => unknown): Promise<void> {\n  stubbedActiveElement = element\n  try {\n    await fn()\n  } finally {\n    stubbedActiveElement = null\n  }\n}\n\nfunction getActiveElement(container: Element): Element | null {\n  if (stubbedActiveElement instanceof Element) {\n    return stubbedActiveElement\n  } else if (container && container.ownerDocument && container.ownerDocument.activeElement) {\n    return container.ownerDocument.activeElement\n  }\n  return null\n}\n\nlet latestMousedownTarget: EventTarget | null\nlet latestMouseupTarget: EventTarget | null\n\nssrSafeDocument?.addEventListener(\n  'mousedown',\n  function (event: Event) {\n    latestMousedownTarget = event.target\n  },\n  true,\n)\n\nssrSafeDocument?.addEventListener(\n  'mouseup',\n  function (event: Event) {\n    latestMousedownTarget = null\n    latestMouseupTarget = event.target\n  },\n  true,\n)\n\nssrSafeDocument?.addEventListener(\n  'contextmenu',\n  function (event: Event) {\n    // Treat `contextmenu` events like `mouseup` events so that we still\n    // update content if the user right-clicks on a safe element.\n    latestMousedownTarget = null\n    latestMouseupTarget = event.target\n  },\n  true,\n)\n\nssrSafeDocument?.addEventListener(\n  'dragend',\n  function () {\n    // Drag and drop does not result in a mouseup event.\n    latestMousedownTarget = null\n  },\n  true,\n)\n\nfunction hasFocus(container: Element, ignoreFocusedContainer: boolean): boolean {\n  const activeElement = getActiveElement(container)\n  if (activeElement === null) return false\n  if (ignoreFocusedContainer && activeElement === container) return false\n\n  // Updatable container hasFocus if one of the following is true:\n  // 1. Focus target is both a form field AND the update target\n  const formFieldFocused = activeElement === container && isFormField(activeElement)\n  if (formFieldFocused) return true\n  // 2. Focus target is relevent (ie not a UPDATABLE_INTERACTIVE_TARGET)\n  //\n  // We consider it safe to update content if the focused element is a button or a link, as\n  // both likely only trigger transient actions\n  const focusTargetIsRelevent = container.contains(activeElement) && !activeElementIsSafe(activeElement)\n  if (focusTargetIsRelevent) return true\n\n  // 3. The last clicked element is an open details summary\n  const interactingWithOpenDetails =\n    latestMouseupTarget instanceof Element &&\n    container.contains(latestMouseupTarget) &&\n    !!latestMouseupTarget.closest('details[open] > summary')\n  return interactingWithOpenDetails\n}\n\nconst UPDATABLE_INTERACTIVE_TARGET = 'a[href], button'\n\nfunction activeElementIsSafe(activeElement: Element): boolean {\n  if (activeElement instanceof DetailsDialogElement) return true\n\n  const isLinkOrButton = activeElement instanceof HTMLAnchorElement || activeElement instanceof HTMLButtonElement\n  const isInsideTaskItem = activeElement.parentElement?.classList.contains('task-list-item')\n  if (isLinkOrButton && isInsideTaskItem) {\n    return true\n  }\n\n  if (!(latestMouseupTarget instanceof Element)) return false\n  const updatableActiveElement = activeElement.closest(UPDATABLE_INTERACTIVE_TARGET)\n  if (!updatableActiveElement) return false\n  const updatableMouseupElement = latestMouseupTarget.closest(UPDATABLE_INTERACTIVE_TARGET)\n  return updatableActiveElement === updatableMouseupElement\n}\n\nfunction hasMousedown(container: Element): boolean {\n  return container.matches(':active:enabled') || container.contains(latestMousedownTarget as Node | null)\n}\n\nfunction markedAsDirty(container: Element): boolean {\n  return container.closest('.is-dirty') || container.querySelector('.is-dirty') ? true : false\n}\n","import morphdom from 'morphdom'\n\nexport type MorpheusOptions = {\n  keepInputValues?: boolean\n}\n\ntype CustomElement = {\n  connectedCallback?(): void\n  disconnectedCallback?(): void\n}\n\nfunction morphdomOptions(options?: MorpheusOptions) {\n  return {\n    getNodeKey: () => {\n      // Since ids often contain uuids, we can't use them as keys.\n      return null\n    },\n    onBeforeElUpdated: (fromEl: HTMLElement, toEl: HTMLElement) => {\n      if (\n        // Workaround: Errors may occur when morphing turbo-frame attributes.\n        toEl.tagName === 'TURBO-FRAME' ||\n        // Workaround: the legacy task list code looks for these elements to be added in order to set them up from JS.\n        toEl.matches('.js-task-list-field, .contains-task-list') ||\n        toEl.getAttribute('data-morpheus-enabled') === 'false'\n      ) {\n        fromEl.replaceWith(toEl)\n        return false\n      }\n\n      // Ensure the data-catalyst attribute added by JS remains.\n      if (fromEl.hasAttribute('data-catalyst')) {\n        toEl.setAttribute('data-catalyst', fromEl.getAttribute('data-catalyst') || '')\n      }\n\n      // Check if there are other attributes we should not update.\n      if (fromEl.hasAttribute('data-morpheus-ignore')) {\n        const names = (fromEl.getAttribute('data-morpheus-ignore') || '').trim().split(/\\s+/)\n        for (const name of names) {\n          if (fromEl.hasAttribute(name)) {\n            toEl.setAttribute(name, fromEl.getAttribute(name) || '')\n          } else {\n            toEl.removeAttribute(name)\n          }\n        }\n      }\n\n      // If the option to keep input values is enabled, copy all input values from the old element to the new one.\n      if (\n        options?.keepInputValues &&\n        ((toEl instanceof HTMLInputElement && toEl.type === (fromEl as HTMLInputElement).type) ||\n          toEl instanceof HTMLTextAreaElement)\n      ) {\n        if (toEl instanceof HTMLInputElement && (toEl.type === 'checkbox' || toEl.type === 'radio')) {\n          toEl.checked = (fromEl as typeof toEl).checked\n        } else {\n          toEl.value = (fromEl as typeof toEl).value\n        }\n      }\n\n      return true\n    },\n    onBeforeElChildrenUpdated: (fromEl: HTMLElement, toEl: HTMLElement) => {\n      // Remove all comment nodes (mostly from the template engine) as they will confuse morphdom.\n      for (const node of [...fromEl.childNodes, ...toEl.childNodes]) {\n        if (node.nodeType === Node.COMMENT_NODE) {\n          node.remove()\n        }\n      }\n\n      return true\n    },\n    onElUpdated: (el: HTMLElement) => {\n      const customEl = el as CustomElement\n\n      if (customEl.connectedCallback) {\n        // Queue microtask to ensure this runs after the children have been updated as well.\n        queueMicrotask(() => {\n          customEl.disconnectedCallback?.()\n          customEl.connectedCallback?.()\n        })\n      }\n    },\n  }\n}\n\nexport function morpheusEnabled(el: Element) {\n  const ancestor = el.closest('[data-morpheus-enabled]')\n  return ancestor != null && ancestor.getAttribute('data-morpheus-enabled') !== 'false'\n}\n\nexport function morph(el: Element, newEl: Node | string, options?: MorpheusOptions) {\n  if (typeof newEl === 'string') {\n    const template = document.createElement('template')\n    template.innerHTML = newEl\n    newEl = template.content\n  }\n\n  if (!morpheusEnabled(el)) {\n    el.replaceWith(newEl)\n    return\n  }\n\n  // Workaround morphdom not correctly handling document fragments.\n  if (newEl instanceof DocumentFragment) {\n    const children = Array.from(newEl.children)\n    if (children.length) {\n      morphdom(el, children[0]!, morphdomOptions(options))\n      el.after(...children.slice(1))\n    } else {\n      el.replaceWith(newEl)\n    }\n  } else {\n    morphdom(el, newEl, morphdomOptions(options))\n  }\n}\n\nexport function morphContent(el: Element, content: string, options?: MorpheusOptions) {\n  if (!morpheusEnabled(el)) {\n    el.innerHTML = content\n    return\n  }\n\n  let leading = ''\n  let trailing = ''\n\n  // Match the leading/trailing whitespace of the existing content so text nodes are not removed.\n  if (el.firstChild?.nodeType === Node.TEXT_NODE) {\n    leading = el.firstChild.nodeValue?.match(/^\\s+/)?.[0] || ''\n  }\n  if (el.lastChild?.nodeType === Node.TEXT_NODE) {\n    trailing = el.lastChild.nodeValue?.match(/\\s+$/)?.[0] || ''\n  }\n\n  const newEl = el.cloneNode(false) as Element\n  newEl.innerHTML = `${leading}${content.trim()}${trailing}`\n\n  morphdom(el, newEl, morphdomOptions(options))\n}\n","export function parseHTML(document: Document, html: string): DocumentFragment {\n  const template = document.createElement('template')\n  template.innerHTML = html\n  return document.importNode(template.content, true)\n}\n","import {hasInteractions} from '@github-ui/has-interactions'\nimport {observe} from '@github/selector-observer'\nimport {morph} from '@github-ui/morpheus'\nimport {parseHTML} from '@github-ui/parse-html'\nimport {preserveAnchorNodePosition} from 'scroll-anchoring'\nimport {replaceState} from '@github-ui/browser-history-state'\nimport {sendStats} from '@github-ui/stats'\n\nconst pendingRequests = new WeakMap<HTMLElement, AbortController>()\nconst staleRecords: {[key: string]: string} = {}\n\n// Wrapper around `window.location.reload()` that forceably cleans out the\n// `staleRecords` state associated with the entry at the top of the history\n// stack before reloading.\nexport function reload() {\n  for (const key of Object.keys(staleRecords)) {\n    delete staleRecords[key]\n  }\n  const stateObject = history.state || {}\n  stateObject.staleRecords = staleRecords\n  replaceState(stateObject, '', location.href)\n  window.location.reload()\n}\n\n// Associates the `staleRecords` object, if it contains any entries, with the\n// entry at top of the history stack.\nexport function registerStaleRecords() {\n  if (Object.keys(staleRecords).length > 0) {\n    const stateObject = history.state || {}\n    stateObject.staleRecords = staleRecords\n    replaceState(stateObject, '', location.href)\n  }\n}\n\n// Fetch and replace container with its data-url.\n//\n// This replacement uses conservative checks to safely replace the element.\n// If a user is interacting with any element within the container, the\n// replacement will be aborted.\nexport async function updateContent(\n  el: HTMLElement,\n  options: {activateScripts: boolean} = {activateScripts: false},\n): Promise<string | void> {\n  if (pendingRequests.get(el)) return\n\n  const retainFocus = el.hasAttribute('data-retain-focus')\n  const url = el.getAttribute('data-url')\n  if (!url) throw new Error('could not get url')\n  const controller = new AbortController()\n  pendingRequests.set(el, controller)\n\n  const headers: {[key: string]: string} = {\n    Accept: 'text/html',\n    'X-Requested-With': 'XMLHttpRequest',\n  }\n\n  try {\n    if (!document.hidden) {\n      sendStats({\n        incrementKey: 'UPDATABLE_CONTENT_XHR_REQUEST_VISIBLE',\n        requestUrl: window.location.href,\n        referredRequestUrl: url,\n      })\n    } else {\n      sendStats({\n        incrementKey: 'UPDATABLE_CONTENT_XHR_REQUEST_INVISIBLE',\n        requestUrl: window.location.href,\n        referredRequestUrl: url,\n      })\n    }\n  } catch {\n    // noop\n  }\n\n  try {\n    const response = await fetch(url, {\n      signal: controller.signal,\n      headers,\n    })\n    if (!response.ok) return\n    const data = await response.text()\n    if (hasInteractions(el, retainFocus)) {\n      // eslint-disable-next-line no-console\n      console.warn('Failed to update content with interactions', el)\n      return\n    }\n    staleRecords[url] = data\n    replace(el, data, {retainFocus, activateScripts: options.activateScripts})\n    return data\n  } catch {\n    // Ignore failed request.\n  } finally {\n    pendingRequests.delete(el)\n  }\n}\n\n// Abort any in-flight replacements and replace element without any interaction checks.\nexport async function replaceContent(el: HTMLElement, data: string, wasStale = false): Promise<void> {\n  const controller = pendingRequests.get(el)\n  controller?.abort()\n\n  const updatable = el.closest('.js-updatable-content[data-url], .js-updatable-content [data-url]')\n  if (!wasStale && updatable && updatable === el) {\n    staleRecords[updatable.getAttribute('data-url') || ''] = data\n  }\n  return replace(el, data, {retainFocus: false, activateScripts: false})\n}\n\nfunction replace(\n  el: HTMLElement,\n  data: string,\n  options: {activateScripts: boolean; retainFocus: boolean},\n): Promise<void> {\n  return preserveAnchorNodePosition(document, () => {\n    const newContent = parseHTML(document, data.trim())\n    if (options.activateScripts) {\n      activateScripts(newContent)\n    }\n\n    const elementToRefocus =\n      options.retainFocus && el.ownerDocument && el === el.ownerDocument.activeElement\n        ? newContent.querySelector('*')\n        : null\n\n    const detailsIds = Array.from(el.querySelectorAll('details[open][id]')).map(element => element.id)\n    if (el.tagName === 'DETAILS' && el.id && el.hasAttribute('open')) detailsIds.push(el.id)\n\n    // Check the elements we are about replace to see if we want to preserve the scroll position of any of them\n    for (const preserveElement of el.querySelectorAll('.js-updatable-content-preserve-scroll-position')) {\n      const id = preserveElement.getAttribute('data-updatable-content-scroll-position-id') || ''\n      heights.set(id, preserveElement.scrollTop)\n    }\n\n    for (const id of detailsIds) {\n      const details = newContent.querySelector(`#${id}`)\n      if (details) details.setAttribute('open', '')\n    }\n\n    morph(el, newContent)\n    if (elementToRefocus instanceof HTMLElement) {\n      elementToRefocus.focus()\n    }\n  })\n}\n\nconst heights = new Map()\nobserve('.js-updatable-content-preserve-scroll-position', {\n  // this type is being interpreted as a value by eslint\n  // eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope\n  constructor: HTMLElement,\n  add(el) {\n    // When element is added to the DOM, check the map for the last scroll position we have on record for it.\n    const id = el.getAttribute('data-updatable-content-scroll-position-id')\n    if (!id) return\n    const height = heights.get(id)\n    if (height == null) return\n\n    el.scrollTop = height\n  },\n})\n\nfunction activateScripts(newHTML: DocumentFragment) {\n  // Get scripts directly accessible from the document fragment\n  const directScripts = Array.from(newHTML.querySelectorAll<HTMLScriptElement>('script[src]'))\n  // Get scripts inside templates\n  const templateScripts = Array.from(newHTML.querySelectorAll<HTMLTemplateElement>('template')).flatMap(template =>\n    Array.from(template.content.querySelectorAll<HTMLScriptElement>('script[src]')),\n  )\n  // Combine both\n  const allScripts = [...directScripts, ...templateScripts]\n\n  for (const script of allScripts) {\n    activateScript(script)\n  }\n}\n\nfunction activateScript(script: HTMLScriptElement) {\n  const {src} = script\n\n  if (!src) {\n    // we can't load a script without a source\n    return\n  }\n\n  // eslint-disable-next-line github/no-dynamic-script-tag\n  const newScript = document.createElement('script')\n  copyScriptAttributes(newScript, script)\n  script.replaceWith(newScript)\n}\n\nfunction copyScriptAttributes(destinationElement: HTMLScriptElement, sourceElement: HTMLScriptElement) {\n  for (const {name, value} of sourceElement.attributes) {\n    destinationElement.setAttribute(name, value)\n  }\n}\n"],"names":["state","turboAction","sessionHistoryEntries","sessionHistoryOffset","getState","safeGetHistory","Math","min","max","ssrSafeHistory","length","setState","newState","url","ssrSafeLocation","href","ssrSafeWindow","dispatchEvent","CustomEvent","bubbles","cancelable","uniqueId","Date","now","pushState","oldState","title","_id","replaceState","initializeState","addEventListener","event","currentState","turbo","restorationIdentifier","id","restoreId","position","detail","action","fire","target","name","requestSubmit","form","submitter","checkButtonValidity","HTMLFormElement","HTMLElement","type","persistSubmitButtonValue","submit","changeValue","input","value","HTMLInputElement","checked","fillFormValues","fields","element","elements","namedItem","HTMLTextAreaElement","isFormField","nodeName","toLowerCase","getAttribute","isContentEditable","searchParamsFromFormData","formData","URLSearchParams","combineGetFormSearchParams","formAction","allSearchParams","search","key","append","toString","serialize","FormData","button","closest","findPersistedSubmitButtonValue","defaultValue","matches","document","createElement","classList","add","prepend","remove","querySelector","stubbedActiveElement","latestMousedownTarget","latestMouseupTarget","hasInteractions","container","ignoreFocusedContainer","ignoreDirtyFields","hasDirtyFields","hasFocus","activeElement","Element","ownerDocument","contains","activeElementIsSafe","DetailsDialogElement","isLinkOrButton","HTMLAnchorElement","HTMLButtonElement","isInsideTaskItem","parentElement","updatableActiveElement","UPDATABLE_INTERACTIVE_TARGET","field","querySelectorAll","formFieldValueChanged","defaultChecked","ssrSafeDocument","morphdomOptions","options","getNodeKey","onBeforeElUpdated","fromEl","toEl","tagName","replaceWith","hasAttribute","setAttribute","trim","split","removeAttribute","keepInputValues","onBeforeElChildrenUpdated","node","childNodes","nodeType","Node","COMMENT_NODE","onElUpdated","customEl","connectedCallback","queueMicrotask","disconnectedCallback","morpheusEnabled","el","ancestor","morph","newEl","template","innerHTML","content","DocumentFragment","children","Array","from","morphdom","after","slice","morphContent","leading","trailing","firstChild","TEXT_NODE","nodeValue","match","lastChild","cloneNode","parseHTML","html","importNode","pendingRequests","WeakMap","staleRecords","reload","Object","keys","stateObject","history","location","window","registerStaleRecords","updateContent","activateScripts","get","retainFocus","controller","AbortController","set","hidden","sendStats","incrementKey","requestUrl","referredRequestUrl","response","fetch","signal","headers","Accept","ok","data","text","console","warn","replace","delete","replaceContent","wasStale","abort","updatable","preserveAnchorNodePosition","newContent","newHTML","script","flatMap","activateScript","src","newScript","copyScriptAttributes","destinationElement","sourceElement","attributes","elementToRefocus","detailsIds","map","preserveElement","push","heights","scrollTop","details","focus","Map","observe","constructor","height"],"sourceRoot":""}