{"version":3,"file":"app_assets_modules_github_blob-anchor_ts-ui_packages_code-nav_code-nav_ts-ui_packages_filter--8253c1-xxxxxxxxxxxx.js","mappings":"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","sources":["app/assets/modules/github/blob-anchor.ts","ui/packages/code-nav/code-navigation-info.ts","ui/packages/code-nav/code-symbol.ts","ui/packages/code-nav/get-match.ts","ui/packages/code-nav/symbol-result-converter.ts","ui/packages/filter-sort/filter-sort.ts","ui/packages/filter-sort/filter-map.ts","ui/packages/fuzzy-filter/fuzzy-filter.ts"],"sourcesContent":["export interface BlobOffset {\n  // Line number\n  // Lines start at 1.\n  line: number\n\n  // Optional column number.\n  // Like lines, columns are 1-indexed.\n  column: number | null\n}\n\nexport interface BlobRange {\n  // Starting offset of range.\n  start: BlobOffset\n\n  // End offset of range.\n  // End offset may be the same as the start. This indicates a collapsed range.\n  // Should always be initialized to a value that is equal or greater than the\n  // start range such the range is always in ascending order. Reversed ranges\n  // have undefined behavior.\n  end: BlobOffset\n}\n\n// Inverse of `formatBlobRange`.\n//\n// Examples\n//\n//   parseBlobRange(\"#L3\")\n//   // => {start: {line: 3}}\n//\n//   parseBlobRange(\"L3-L5\")\n//   // => {start: {line: 3}, end: {line: 5}}\n//\n//   parseBlobRange(\"\")\n//   // => null\nexport function parseBlobRange(str: string): BlobRange | undefined {\n  const lines = str.match(/#?(?:L)(\\d+)((?:C)(\\d+))?/g)\n  if (!lines) {\n    return\n  } else if (lines.length === 1) {\n    const offset = parseBlobOffset(lines[0])\n    if (!offset) return\n    return Object.freeze({start: offset, end: offset})\n  } else if (lines.length === 2) {\n    const startOffset = parseBlobOffset(lines[0])\n    const endOffset = parseBlobOffset(lines[1]!)\n    if (!startOffset || !endOffset) return\n\n    return ascendingBlobRange(\n      Object.freeze({\n        start: startOffset,\n        end: endOffset,\n      }),\n    )\n  } else {\n    return\n  }\n}\n\n// Inverse of `parseBlobRange`.\n//\n// Examples\n//\n//   formatBlobRange({start: {line: 3}})\n//   // => \"L3\"\n//\n//   formatBlobRange({start: {line: 3}, end: {line: 5}})\n//   // => \"L3-L5\"\n//\n//   formatBlobRange({start: {line: 3, column: 1}, end: {line: 5, column: 5}})\n//   // => \"L3C1-L5C5\"\n//\n//   formatBlobRange({start: {line: 3, column: 1}, end: {line: 5,}})\n//   // => \"L3C1-L5\"\nexport function formatBlobRange(blobRange: BlobRange): string {\n  const {start, end} = ascendingBlobRange(blobRange)\n\n  if (start.column != null && end.column != null) {\n    return `L${start.line}C${start.column}-L${end.line}C${end.column}`\n  } else if (start.column != null) {\n    return `L${start.line}C${start.column}-L${end.line}`\n  } else if (end.column != null) {\n    return `L${start.line}-L${end.line}C${end.column}`\n  } else if (start.line === end.line) {\n    return `L${start.line}`\n  } else {\n    return `L${start.line}-L${end.line}`\n  }\n}\n\n// Returns a String containing the file prefix with trailing dash.\n//\n// Examples\n//\n//   parseAnchorPrefix(\"#file-zshrc-L3\")\n//   // => \"file-zshrc-\"\n//\n//   parseAnchorPrefix(\"file-zshrc-L3-L5\")\n//   // => \"file-zshrc-\"\n//\n//   parseAnchorPrefix(\"\")\n//   // => \"\"\nfunction parseAnchorPrefix(str: string): string {\n  const match = str.length < 5000 && str.match(/(file-.+?-)L\\d+?/i)\n  return match ? match[1]! : ''\n}\n\nexport type AnchorInfo = {\n  blobRange: BlobRange\n  anchorPrefix: string\n}\n\n// Examples\n//\n//   parseFileAnchor(\"#file-zshrc-L3\")\n//   // => { blobRange: {start: {line: 3}}, anchorPrefix: \"file-zshrc-\" }\n//\n//   parseFileAnchor(\"file-zshrc-L3-L5\")\n//   // => { blobRange: {start: {line: 3}, end: {line: 5}}, anchorPrefix: \"file-zshrc-\" }\n//\n//   parseFileAnchor(\"\")\n//   // => { blobRange: null, anchorPrefix: undefined }\nexport function parseFileAnchor(str: string): AnchorInfo {\n  const blobRange = parseBlobRange(str)!\n  const anchorPrefix = parseAnchorPrefix(str)\n  return {blobRange, anchorPrefix}\n}\n\n// Formats line number range pair as an anchor String.\n//\n// Examples\n//\n//   formatBlobRangeAnchor({blobRange: {start: {line: 3}}, anchorPrefix: \"\"})\n//   // => \"#L3\"\n//\n//   formatBlobRangeAnchor({blobRange: {start: {line: 3}}, anchorPrefix: \"file-zshrc-\"})\n//   // => \"#file-zshrc-L3\"\n//\n//   formatBlobRangeAnchor({blobRange: {start: {line: 3}, end: {line: 5}}, anchorPrefix: \"\"})\n//   // => \"#L3-L5\"\n//\n//   formatBlobRangeAnchor({blobRange: {start: {line: 3, column: 1}, end: {line: 5, column: 5}}, anchorPrefix: \"\"})\n//   // => \"#L3C1-L5C5\"\n//\n//   formatBlobRangeAnchor({blobRange: {start: {line: 3}, end: {line: 5}}, anchorPrefix: \"file-zshrc-\"})\n//   // => \"#file-zshrc-L3-L5\"\n//\n//   formatBlobRangeAnchor({blobRange: null, anchorPrefix: \"\"})\n//   // => \"#\"\n//\n//   formatBlobRangeAnchor({blobRange: null, anchorPrefix: \"file-zshrc-\"})\n//   // => \"#\"\nexport function formatBlobRangeAnchor({anchorPrefix, blobRange}: AnchorInfo): string {\n  if (!blobRange) return '#'\n  return `#${anchorPrefix}${formatBlobRange(blobRange)}`\n}\n\nfunction parseBlobOffset(str: string): BlobOffset | null {\n  const lineMatch = str.match(/L(\\d+)/)\n  const columnMatch = str.match(/C(\\d+)/)\n  if (lineMatch) {\n    return Object.freeze({\n      line: parseInt(lineMatch[1]!),\n      column: columnMatch ? parseInt(columnMatch[1]!) : null,\n    })\n  } else {\n    return null\n  }\n}\n\nexport function DOMRangeFromBlob(\n  blobRange: BlobRange,\n  getLineElement: (line: number) => Node | null,\n): Range | undefined {\n  const [startContainer, _startOffset] = findRangeOffset(blobRange.start, true, getLineElement)\n  const [endContainer, _endOffset] = findRangeOffset(blobRange.end, false, getLineElement)\n  if (!startContainer || !endContainer) return\n\n  // Treat -1 as full line selection\n  let startOffset = _startOffset\n  let endOffset = _endOffset\n  if (startOffset === -1) startOffset = 0\n  if (endOffset === -1) endOffset = endContainer.childNodes.length\n  if (!startContainer.ownerDocument) throw new Error(`DOMRange needs to be inside document`)\n\n  const range = startContainer.ownerDocument.createRange()\n  range.setStart(startContainer, startOffset)\n  range.setEnd(endContainer, endOffset)\n  return range\n}\n\nfunction findRangeOffset(\n  offset: BlobOffset,\n  lookAhead: boolean,\n  getLineElement: (n: number) => Node | null,\n): [Node | null, number] {\n  const error: [null, number] = [null, 0]\n\n  const lineElement = getLineElement(offset.line)\n  if (!lineElement) return error\n\n  if (offset.column == null) {\n    return [lineElement, -1]\n  }\n\n  let column = offset.column - 1\n\n  const textNodes = getAllTextNodes(lineElement)\n  for (let i = 0; i < textNodes.length; i++) {\n    const textNode = textNodes[i]!\n\n    // TODO: length might be buggy with emoji\n    const nextC = column - (textNode.textContent || '').length\n\n    if (nextC === 0) {\n      const nextTextNode = textNodes[i + 1]\n      if (lookAhead && nextTextNode) {\n        return [nextTextNode, 0]\n      } else {\n        return [textNode, column]\n      }\n    } else if (nextC < 0) {\n      return [textNode, column]\n    }\n\n    column = nextC\n  }\n\n  return error\n}\n\n// Get a flat list of text nodes in depth first order.\nfunction getAllTextNodes(el: Node): Node[] {\n  if (el.nodeType === Node.TEXT_NODE) {\n    return [el]\n  }\n  if (!el.childNodes || !el.childNodes.length) return []\n  let list: Node[] = []\n  for (const node of el.childNodes) {\n    list = list.concat(getAllTextNodes(node))\n  }\n  return list\n}\n\n// Sorts range start and end offsets to be in ascending order.\nfunction ascendingBlobRange(range: BlobRange): BlobRange {\n  const offsets = [range.start, range.end]\n  offsets.sort(compareBlobOffsets)\n\n  if (offsets[0] === range.start && offsets[1] === range.end) {\n    return range\n  } else {\n    return Object.freeze({\n      start: offsets[0]!,\n      end: offsets[1]!,\n    })\n  }\n}\n\n// Compare line offsets. May be used with Array.sort\nfunction compareBlobOffsets(a: BlobOffset, b: BlobOffset): number {\n  if (a.line === b.line && a.column === b.column) {\n    return 0\n  } else if (a.line === b.line && typeof a.column === 'number' && typeof b.column === 'number') {\n    return a.column - b.column\n  } else {\n    return a.line - b.line\n  }\n}\n","import type {Repository} from '@github-ui/current-repository'\nimport {codeNavigationPath} from '@github-ui/paths'\nimport {verifiedFetchJSON} from '@github-ui/verified-fetch'\n\nimport type {RefInfo} from '@github-ui/repos-types'\nimport type {BlackbirdSymbol, StylingDirectivesDocument} from '@github-ui/code-view-types'\nimport type {\n  CodeNavBackendType,\n  CodeNavPromise,\n  CodeNavResultDetails,\n  SymbolTreeBuildingData,\n  TreeNode,\n} from './code-nav-types'\nimport {\n  CodeReference,\n  type CodeSymbol,\n  type DefinitionOrReference,\n  type Range,\n  SymbolKind,\n  SymbolSource,\n} from './code-symbol'\nimport {getMatchGenerator, type Matchable, symbolMatchable, textMatchable} from './get-match'\nimport {alephSymbolToCodeReference, alephSymbolToCodeSymbol, outlineSymbolToCodeSymbol} from './symbol-result-converter'\n\nconst SEARCH_RESULT_LIMIT = 200\n\nexport interface CodeSection {\n  startLine: number\n  endLine: number\n  collapsed: boolean\n  index: number\n  level: number\n}\n\nexport class CodeNavigationInfo {\n  repo: Repository\n  refInfo: RefInfo\n  language: string\n  path: string\n  loggedIn: boolean\n  blobLines: string[]\n  symbols: CodeSymbol[]\n  lineIndexedSymbols: {[line: number]: CodeSymbol} = {}\n  isPlain: boolean\n\n  symbolTree: TreeNode[]\n  stylingDirectives: StylingDirectivesDocument | undefined\n  setLoading: (loading: boolean) => void\n  codeSections: Map<number, CodeSection[]>\n  lineToSectionMap: Map<number, CodeSection[]>\n\n  constructor(\n    repo: Repository,\n    refInfo: RefInfo,\n    path: string,\n    loggedIn: boolean,\n    rawLines: string[],\n    symbols: BlackbirdSymbol[],\n    stylingDirectives: StylingDirectivesDocument | undefined,\n    language: string,\n    isPlain: boolean,\n    setLoading: (loading: boolean) => void,\n  ) {\n    this.setLoading = setLoading\n    this.setLoading(true)\n    this.repo = repo\n    this.refInfo = refInfo\n    this.path = path\n    this.loggedIn = loggedIn\n    this.language = language\n\n    this.blobLines = rawLines\n    this.stylingDirectives = stylingDirectives\n    this.isPlain = isPlain\n    this.symbols = this.initSymbols(symbols)\n\n    this.initSymbolTree()\n    this.initCodeSections()\n    this.setLoading(false)\n  }\n\n  initCodeSections() {\n    const m = new Map()\n    const lineToSectionMap = new Map()\n    for (let i = 0; i < this.symbols.length; i++) {\n      //we don't want to deal with applying sticky if it is going to be a 2 line long sticky section\n      if (this.symbols[i]!.lineNumber < this.symbols[i]!.extent.end.line - 2) {\n        const section = {\n          startLine: this.symbols[i]!.lineNumber,\n          endLine: this.symbols[i]!.extent.end.line,\n          index: i,\n          collapsed: false,\n          level: this.symbols[i]!.depth,\n        }\n        if (m.has(section.startLine)) {\n          const tempArray = m.get(section.startLine)\n          tempArray.push(section)\n          m.set(section.startLine, tempArray)\n        } else {\n          m.set(section.startLine, [section])\n        }\n        if (m.has(section.endLine)) {\n          const tempArray = m.get(section.endLine)\n          tempArray.push(section)\n          m.set(section.endLine, tempArray)\n        } else {\n          m.set(section.endLine, [section])\n        }\n\n        //don't include the start lines or end lines because they're in the other map\n        for (let j = section.startLine + 1; j < section.endLine; j++) {\n          if (lineToSectionMap.has(j)) {\n            const tempArray = lineToSectionMap.get(j)\n            tempArray.push(section)\n            lineToSectionMap.set(j, tempArray)\n          } else {\n            lineToSectionMap.set(j, [section])\n          }\n        }\n      }\n    }\n\n    this.lineToSectionMap = lineToSectionMap\n    this.codeSections = m\n  }\n\n  initSymbols(symbols: BlackbirdSymbol[]) {\n    return symbols.map(outlineSymbol => {\n      const snippet = this.blobLines[outlineSymbol.ident_utf16.start.line_number] || ''\n      const codeSymbol = outlineSymbolToCodeSymbol(outlineSymbol, snippet, {\n        stylingDirectives: this.stylingDirectives,\n        repo: this.repo,\n        refInfo: this.refInfo,\n        path: this.path,\n      })\n\n      this.lineIndexedSymbols[codeSymbol.lineNumber] = codeSymbol\n\n      return codeSymbol\n    })\n  }\n\n  getBlobLine(line: number) {\n    return this.blobLines[line] || ''\n  }\n\n  getSymbolOnLine(lineNumber: number): CodeSymbol | undefined {\n    return this.lineIndexedSymbols[lineNumber]\n  }\n\n  initSymbolTree() {\n    if (this.symbols) {\n      const tempParents: CodeSymbol[] = []\n      const symbolTree: SymbolTreeBuildingData[] = this.symbols\n        .filter(s => s.kind.fullName !== 'field')\n        .map(symbol => {\n          let depth = 0\n          for (let i = tempParents.length - 1; i >= 0; i--) {\n            const parentSymbol = tempParents[i]!\n            if (isAfterSymbol(symbol, parentSymbol)) {\n              tempParents.pop()\n            } else {\n              depth = tempParents.length\n              break\n            }\n          }\n          tempParents.push(symbol)\n          symbol.setSymbolDepth(depth)\n          return {symbol, depth}\n        })\n      this.symbolTree = []\n\n      for (let index = 0; index < symbolTree.length; index++) {\n        const symbol = symbolTree[index]!\n        if (index + 1 < symbolTree.length) {\n          const nextSymbol = symbolTree[index + 1]!\n          if (nextSymbol.depth > symbol.depth) {\n            const symbolChildren = buildSymbolTreeChildren(symbolTree, index)\n            index += determineTotalNumberOfChildren(symbolChildren)\n            this.symbolTree.push({symbol: symbol.symbol, isParent: true, children: symbolChildren})\n            continue\n          }\n        }\n        this.symbolTree.push({symbol: symbol.symbol, isParent: false, children: []})\n      }\n    }\n  }\n\n  createReferences(matches: Range[]): CodeReference[] {\n    return matches.map(match => {\n      const reference = new CodeReference({\n        ident: match,\n        repo: this.repo,\n        refInfo: this.refInfo,\n        path: this.path,\n        isPlain: this.isPlain,\n        source: SymbolSource.BLOB_CONTENT,\n      })\n      reference.setSnippet(\n        undefined,\n        this.stylingDirectives?.[match.start.line],\n        this.blobLines[match.start.line]!,\n        undefined,\n      )\n      return reference\n    })\n  }\n\n  getReferencesToSymbol(symbolName: string): CodeReference[] {\n    //TODO: figure out loading once this is async\n    const ranges = searchInBlobContent(this.blobLines, symbolMatchable(symbolName))\n    return this.createReferences(ranges)\n  }\n\n  getReferencesToSearch(term: string): CodeReference[] {\n    //TODO: figure out loading once this is async\n    const ranges = searchInBlobContent(this.blobLines, textMatchable(term))\n    return this.createReferences(ranges)\n  }\n\n  getDefinitionsAndReferences(text: string, row: number, column: number): CodeNavPromise {\n    this.setLoading(true)\n\n    const defs = (async () => {\n      const selectedSymbol = this.getSymbolOnLine(row + 1) // row is 0-indexed, line numbers are 1-indexed\n      if (selectedSymbol && selectedSymbol.name === text) {\n        return {\n          definitions: [selectedSymbol],\n          backend: 'search' as CodeNavBackendType,\n        }\n      }\n\n      let [definitions, backend] = await this.getAlephDefinitions(text, row, column, this.loggedIn)\n\n      // Prefer locally-defined symbols over search-based definitions, unless precise results are available.\n      if (backend === 'search') {\n        const localDefinitions = this.getLocalDefinitions(text)\n        if (localDefinitions.length > 0) {\n          definitions = localDefinitions\n        }\n\n        // If we get a definition from the current file, suppress all the others\n        const localDefinition = definitions.find(d => d.path === this.path && d.repo === this.repo)\n        if (localDefinition) {\n          definitions = [localDefinition]\n        }\n        backend = 'search'\n      } else {\n        const localDefinitionsForKindFallback = this.getLocalDefinitions(text, true)\n        for (const definition of definitions) {\n          if (definition.kind.fullName === '' && definition.name === text) {\n            //local definitions always returns an array with a single item if it returns anything\n            //instead of empty string we can choose a default kind to display here when aleph and local have nothing,\n            //but for now keeping as empty string\n            definition.kind = localDefinitionsForKindFallback[0]\n              ? localDefinitionsForKindFallback[0].kind\n              : new SymbolKind({kind: ''})\n          }\n        }\n      }\n      return {\n        definitions,\n        backend,\n      }\n    })()\n\n    const localRefs = (async () => {\n      const {definitions} = await defs\n      const definitionLines = definitions.map(d => d.lineNumber)\n      const references = this.getReferencesToSymbol(text).filter(r => !definitionLines.includes(r.lineNumber))\n\n      return {\n        references,\n        backend: 'search' as CodeNavBackendType,\n      }\n    })()\n\n    const alephRefs = (async () => {\n      let symbolKind = 'SYMBOL_KIND_UNKNOWN'\n      const sym = this.getSymbolOnLine(row + 1) // row is 0-indexed, line numbers are 1-indexed\n      if (sym) {\n        // If we have this in the symbol outline (from blackbird analysis): use it.\n        symbolKind = sym.kind.enumStringVal\n      } else {\n        // Otherwise, try to use the first def\n        const {definitions} = await defs\n        symbolKind = definitions[0]?.kind?.enumStringVal || symbolKind\n      }\n      return this.getAlephReferences(text, row, column, this.loggedIn, symbolKind)\n    })()\n\n    const crossRefs = (async () => {\n      const [references, backend] = await alephRefs\n      return {\n        references,\n        backend,\n      }\n    })()\n\n    // Exclude definitions from references\n    return {\n      definitions: defs,\n      localReferences: localRefs,\n      crossReferences: crossRefs,\n      setLoading: this.setLoading,\n    }\n  }\n\n  getLocalDefinitions(text: string, getSymbolKind = false): CodeSymbol[] {\n    let bestRank = 9\n    let definitions: CodeSymbol[] = []\n    for (const sym of this.symbols) {\n      if (sym.name === text && (sym.kind.rank < bestRank || getSymbolKind)) {\n        bestRank = sym.kind.rank\n        definitions = [sym]\n      }\n    }\n\n    return definitions\n  }\n\n  async getAlephDefinitions(\n    text: string,\n    row: number,\n    column: number,\n    loggedIn: boolean,\n  ): Promise<[CodeSymbol[], CodeNavBackendType]> {\n    let backend: CodeNavBackendType = 'search'\n    if ((text === '' && row === -1 && column === -1) || !loggedIn) {\n      return [[], backend]\n    }\n\n    const definitionsUrl = codeNavigationPath({\n      repo: this.repo,\n      type: 'definition',\n      q: text,\n      language: this.language,\n      row,\n      column,\n      ref: this.refInfo.name,\n      path: this.path,\n      codeNavContext: 'BLOB_VIEW',\n      symbolKind: null,\n    })\n\n    let response: Response\n    try {\n      response = await verifiedFetchJSON(definitionsUrl)\n    } catch {\n      return [[], backend]\n    }\n\n    if (!response.ok) {\n      return [[], backend]\n    }\n\n    let resultDetails: CodeNavResultDetails\n    try {\n      resultDetails = await response.json()\n    } catch {\n      return [[], backend]\n    }\n\n    backend = parseAlephBackendType(resultDetails.backend) ?? 'search'\n\n    const definitions = resultDetails.payload\n      .flatMap(refs => refs)\n      .map(alephSymbol => {\n        return alephSymbolToCodeSymbol(alephSymbol, {\n          stylingDirectives: this.stylingDirectives,\n          repo: this.repo,\n          refInfo: this.refInfo,\n          path: this.path,\n          symbol: text,\n          backend,\n        })\n      })\n\n    return [definitions, backend]\n  }\n\n  async getAlephReferences(\n    text: string,\n    row: number,\n    column: number,\n    loggedIn: boolean,\n    symbolKind: string,\n  ): Promise<[CodeReference[], CodeNavBackendType]> {\n    let backend: CodeNavBackendType = 'search'\n    if ((text === '' && row === -1 && column === -1) || !loggedIn) {\n      return [[], backend]\n    }\n\n    const referencesUrl = codeNavigationPath({\n      repo: this.repo,\n      type: 'references',\n      q: text,\n      language: this.language,\n      row,\n      column,\n      ref: this.refInfo.name,\n      path: this.path,\n      codeNavContext: 'BLOB_VIEW',\n      symbolKind,\n    })\n\n    const partialResponse = await verifiedFetchJSON(referencesUrl)\n    if (!partialResponse.ok) {\n      return [[], backend]\n    }\n\n    let response: CodeNavResultDetails\n    try {\n      response = await partialResponse.json()\n    } catch {\n      return [[], backend]\n    }\n\n    backend = parseAlephBackendType(response.backend) ?? 'search'\n\n    const observedLines = new Set<number>()\n    const isCheckedLine = (line: number) => {\n      if (observedLines.has(line)) {\n        return true\n      } else {\n        observedLines.add(line)\n        return false\n      }\n    }\n\n    const references = response.payload\n      .flatMap(refs => refs)\n      .reduce<CodeReference[]>((results, alephSymbol) => {\n        if (alephSymbol.path === this.path) {\n          return results\n        }\n        const reference = alephSymbolToCodeReference(alephSymbol, {\n          stylingDirectives: this.stylingDirectives,\n          repo: this.repo,\n          refInfo: this.refInfo,\n          path: this.path,\n          backend,\n        })\n\n        if (isCheckedLine(reference.lineNumber)) {\n          return results\n        }\n\n        results.push(reference)\n        return results\n      }, [])\n      // For some reason, aleph returns references out of order, so we need to sort\n      // them by line number.\n      .sort((a, b) => a.lineNumber - b.lineNumber)\n\n    return [references, backend]\n  }\n}\n\nexport function parseAlephBackendType(fromAleph: string): CodeNavBackendType | null {\n  switch (fromAleph) {\n    case 'ALEPH_PRECISE':\n    case 'ALEPH_PRECISE_PREVIEW':\n    case 'ALEPH_PRECISE_DEVELOPMENT':\n      return 'precise'\n    case 'BLACKBIRD':\n      return 'search'\n    default:\n      return null\n  }\n}\n\nexport function isAfterSymbol(symbolA: CodeSymbol, symbolB: CodeSymbol): boolean {\n  return symbolA.extent.start.line === symbolB.extent.end.line\n    ? symbolA.extent.start.column > symbolB.extent.end.column\n    : symbolA.extent.start.line > symbolB.extent.end.line\n}\n\nfunction buildSymbolTreeChildren(symbolTree: SymbolTreeBuildingData[], currentIndex: number) {\n  const symbolChildren: TreeNode[] = []\n  const symbol = symbolTree[currentIndex]!\n  for (let i = currentIndex + 1; i < symbolTree.length; i++) {\n    const tempSymbol = symbolTree[i]!\n    if (tempSymbol.depth > symbol.depth) {\n      const tempChildren = buildSymbolTreeChildren(symbolTree, i)\n      i += determineTotalNumberOfChildren(tempChildren)\n      symbolChildren.push({\n        symbol: tempSymbol.symbol,\n        children: tempChildren,\n        isParent: tempChildren.length > 0,\n      })\n    } else {\n      break\n    }\n  }\n  return symbolChildren\n}\n\nfunction determineTotalNumberOfChildren(node: TreeNode[]) {\n  let total = node.length\n  for (let i = 0; i < node.length; i++) {\n    const currNode = node[i]!\n    if (currNode.isParent) {\n      total += determineTotalNumberOfChildren(currNode.children)\n    }\n  }\n\n  return total\n}\n\nexport function searchInBlobContent(lines: string[], m: Matchable): Range[] {\n  const output: Range[] = []\n  const matches = getMatchGenerator(m, lines)\n  let match = matches.next()\n\n  while (!match.done && output.length < SEARCH_RESULT_LIMIT) {\n    const {column, columnEnd, line} = match.value\n    output.push({\n      start: {\n        line,\n        column,\n      },\n      end: {\n        line,\n        column: columnEnd,\n      },\n    })\n\n    match = matches.next()\n  }\n  return output\n}\n\nexport function searchInBlobIncrementally(\n  codeRefs: DefinitionOrReference[],\n  lines: string[],\n  matchable: Matchable,\n): Range[] {\n  if (codeRefs.length === 0) {\n    // In the incremental search we are narrowing results. If there are no results for a less specific search, there won't be any further matches.\n    return []\n  }\n\n  const startedAtResultLimit = codeRefs.length >= SEARCH_RESULT_LIMIT\n\n  const checkedLine: Record<number, true> = {}\n  const searchResults = codeRefs.reduce<Range[]>((output, ref) => {\n    if (checkedLine[ref.ident.start.line]) {\n      return output\n    }\n\n    checkedLine[ref.ident.start.line] = true\n    const matches = getMatchGenerator(matchable, [lines[ref.ident.start.line]!])\n    let match = matches.next()\n    while (!match.done && output.length < SEARCH_RESULT_LIMIT) {\n      const {column, columnEnd} = match.value\n      output.push({\n        start: {\n          line: ref.ident.start.line,\n          column,\n        },\n        end: {\n          line: ref.ident.start.line,\n          column: columnEnd,\n        },\n      })\n      match = matches.next()\n    }\n\n    return output\n  }, [])\n\n  // Add new results from the raw blob. Note: this is only necessary if we dropped the number\n  // of results below the maximum in the previous phase!\n  if (searchResults.length < SEARCH_RESULT_LIMIT && startedAtResultLimit) {\n    const startFromLine = codeRefs[codeRefs.length - 1]!.ident.start.line\n    const matchesInRawBlob = getMatchGenerator(matchable, lines, startFromLine)\n    let match = matchesInRawBlob.next()\n    while (!match.done && searchResults.length < SEARCH_RESULT_LIMIT) {\n      const {line, column, columnEnd} = match.value\n      searchResults.push({\n        start: {\n          line,\n          column,\n        },\n        end: {\n          line,\n          column: columnEnd,\n        },\n      })\n      match = matchesInRawBlob.next()\n    }\n  }\n\n  return searchResults\n}\n","import type {Repository} from '@github-ui/current-repository'\nimport type {StylingDirectivesLine} from '@github-ui/code-view-types'\nimport {blamePath, blobPath} from '@github-ui/paths'\nimport type {RefInfo} from '@github-ui/repos-types'\nimport type {SafeHTMLString} from '@github-ui/safe-html'\n\ninterface Position {\n  line: number\n  column: number\n}\n\nexport interface Range {\n  start: Position\n  end: Position\n}\n\nexport enum SymbolSource {\n  BLACKBIRD_SEARCH = 'blackbird-search',\n  BLACKBIRD_ANALYSIS = 'blackbird-analysis',\n  ALEPH_PRECISE = 'aleph-precise',\n  BLOB_CONTENT = 'blob-content-search',\n}\n\nexport class SymbolKind {\n  enumStringVal: string\n  fullName: string\n  shortName: string\n  plColor: string\n  rank: number\n\n  constructor({kind}: {kind: string | number}) {\n    const [fullName, enumStringVal] = convertBlackbirdSymbolKind(kind)\n\n    this.enumStringVal = enumStringVal\n    this.fullName = fullName\n    this.shortName = symbolKindShortName(fullName)\n    this.plColor = symbolKindColor(fullName)\n    this.rank = symbolKindRank(fullName)\n  }\n}\n\n// Convert a blackbird SymbolKind enum value to a display friendly string.\n// Source of truth: https://github.com/github/hydro-schemas/blob/main/proto/hydro/schemas/blackbird/v0/entities/symbol_kind.proto\nfunction convertBlackbirdSymbolKind(kind: string | number): [string, string] {\n  if (typeof kind === 'string') {\n    const name = kind.toString().replace('SYMBOL_KIND_', '').replace(/_DEF$/, '').replace(/_REF$/, '').toLowerCase()\n    if (kind.startsWith('SYMBOL_KIND_')) {\n      return [name, kind.toString()]\n    } else if (kind !== '' && kind !== 'unknown') {\n      let enumVal = `SYMBOL_KIND_${kind.toUpperCase()}`\n      if (kind === 'call') {\n        enumVal += '_REF'\n      } else {\n        enumVal += '_DEF'\n      }\n      return [kind, enumVal]\n    }\n  }\n\n  return ['unknown', 'SYMBOL_KIND_UNKNOWN']\n}\n\nexport function symbolKindShortName(fullName: string) {\n  switch (fullName) {\n    case 'function':\n    case 'method':\n      return 'func'\n    case 'interface':\n      return 'intf'\n    case 'implementation':\n      return 'impl'\n    case 'constant':\n      return 'const'\n    case 'module':\n      return 'mod'\n\n    case 'h1':\n    case 'h2':\n    case 'h3':\n    case 'h4':\n    case 'h5':\n    case 'h6':\n    case 'class':\n    case 'call':\n    case 'enum':\n    case 'field':\n    case 'macro':\n    case 'struct':\n    case 'trait':\n    case 'type':\n    case 'union':\n      return fullName\n\n    default:\n      return fullName.substring(0, 1)\n  }\n}\n\nfunction symbolKindColor(fullName: string) {\n  switch (fullName) {\n    case 'function':\n    case 'method':\n      return 'prettylights.syntax.entity'\n    case 'class':\n    case 'enum':\n    case 'struct':\n    case 'union':\n      return 'prettylights.syntax.constant'\n    case 'interface':\n    case 'trait':\n      return 'prettylights.syntax.keyword'\n    case 'constant':\n    case 'field':\n    case 'enum member':\n      return 'prettylights.syntax.variable'\n    case 'implementation':\n      return 'prettylights.syntax.string'\n\n    default:\n      return 'prettylights.syntax.entity'\n  }\n}\n\n// Relative rank of symbol kinds. Lower is higher relevance.\nfunction symbolKindRank(kind: string): number {\n  return (\n    {\n      class: 1,\n      struct: 1,\n      enum: 1,\n      type: 2,\n      interface: 3,\n      trait: 3,\n      module: 4,\n      implementation: 5,\n      function: 6,\n      method: 7,\n      call: 8,\n      field: 9,\n    }[kind] || 9\n  )\n}\n\nexport class CodeSymbol {\n  ident: Range\n  extent: Range\n\n  kind: SymbolKind\n  name: string\n  fullyQualifiedName: string\n  depth: number\n\n  repo: Repository\n  refInfo: RefInfo\n  path: string\n\n  // Snippet for the line the symbol is defined on\n  highlightedText: SafeHTMLString | undefined\n  stylingDirectives: StylingDirectivesLine | undefined\n  bodyText: string\n  leadingWhitespace: number | undefined\n\n  source: SymbolSource\n\n  constructor({\n    ident,\n    extent,\n    kind,\n    name,\n    fullyQualifiedName,\n    source,\n  }: {\n    ident: Range\n    extent: Range\n    kind: string | number\n    name: string\n    fullyQualifiedName: string\n    source: SymbolSource\n  }) {\n    this.ident = ident\n    this.extent = extent\n    this.kind = new SymbolKind({kind})\n    this.name = name\n    this.fullyQualifiedName = fullyQualifiedName\n    this.source = source\n  }\n\n  setSymbolDepth(depth: number) {\n    this.depth = depth\n  }\n  setFileInfo(repo: Repository, refInfo: RefInfo, path: string) {\n    this.repo = repo\n    this.refInfo = refInfo\n    this.path = path\n  }\n\n  get lineNumber() {\n    return this.ident.start.line + 1\n  }\n\n  setSnippet(\n    highlightedText: SafeHTMLString | undefined,\n    stylingDirectives: StylingDirectivesLine | undefined,\n    bodyText: string,\n    leadingWhitespace: number | undefined,\n  ) {\n    this.highlightedText = highlightedText\n    this.stylingDirectives = stylingDirectives\n    this.bodyText = bodyText\n    this.leadingWhitespace = leadingWhitespace\n  }\n\n  href(): string {\n    if (!this.repo || !this.refInfo || !this.path) {\n      return `/${window.location.pathname}#L${this.lineNumber}`\n    }\n\n    const commitish =\n      this.source === SymbolSource.BLACKBIRD_SEARCH\n        ? this.repo.defaultBranch\n        : this.refInfo.name || this.refInfo.currentOid\n\n    return blobPath({\n      owner: this.repo.ownerLogin,\n      repo: this.repo.name,\n      commitish,\n      filePath: this.path,\n      lineNumber: this.lineNumber,\n    })\n  }\n\n  // Generates a string which uniquely identifies the file this reference comes from\n  pathKey(): string {\n    return `${this.repo.ownerLogin}/${this.repo.name}/${this.refInfo.currentOid}/${this.path}`\n  }\n}\n\nexport class CodeReference {\n  ident: Range\n  repo: Repository\n  refInfo: RefInfo\n  path: string\n  isPlain: boolean\n\n  // Snippet information for the line the reference is from\n  highlightedText: SafeHTMLString | undefined\n  stylingDirectives: StylingDirectivesLine | undefined\n  bodyText: string\n  source: SymbolSource\n  leadingWhitespace: number | undefined\n\n  constructor({\n    ident,\n    repo,\n    refInfo,\n    path,\n    isPlain,\n    source,\n  }: {\n    ident: Range\n    repo: Repository\n    refInfo: RefInfo\n    path: string\n    isPlain?: boolean\n    source: SymbolSource\n  }) {\n    this.ident = ident\n    this.repo = repo\n    this.refInfo = refInfo\n    this.path = path\n    this.isPlain = isPlain ?? false\n    this.source = source\n  }\n\n  get lineNumber() {\n    return this.ident.start.line + 1\n  }\n\n  href(blame: boolean): string {\n    if (!this.repo || !this.refInfo || !this.path) {\n      return `/${window.location.pathname}#L${this.lineNumber}`\n    }\n\n    const commitish =\n      this.source === SymbolSource.BLACKBIRD_SEARCH\n        ? this.repo.defaultBranch\n        : this.refInfo.name || this.refInfo.currentOid\n\n    const params = {\n      owner: this.repo.ownerLogin,\n      repo: this.repo.name,\n      commitish,\n      filePath: this.path,\n      lineNumber: this.lineNumber,\n      plain: this.isPlain ? 1 : undefined,\n    }\n\n    return blame ? blamePath(params) : blobPath(params)\n  }\n\n  setSnippet(\n    highlightedText: SafeHTMLString | undefined,\n    stylingDirectives: StylingDirectivesLine | undefined,\n    bodyText: string,\n    leadingWhitespace: number | undefined,\n  ) {\n    this.highlightedText = highlightedText\n    this.stylingDirectives = stylingDirectives\n    this.bodyText = bodyText\n    this.leadingWhitespace = leadingWhitespace\n  }\n\n  // Generates a string which uniquely identifies the file this reference comes from\n  pathKey(): string {\n    return `${this.repo.ownerLogin}/${this.repo.name}/${this.refInfo.currentOid}/${this.path}`\n  }\n}\n\nexport type DefinitionOrReference = CodeSymbol | CodeReference\n","/**\n * Lazy iterator that returns one match at a time\n * @param regex regular expression used for the search\n * @param text raw text blob\n * @param startFromLine line in the text blob indexed from 0\n */\n\nenum MatchableType {\n  Text,\n  Symbol,\n}\n\nexport interface Matchable {\n  kind: MatchableType\n  regexp: RegExp\n}\n\nexport function symbolMatchable(symbol: string) {\n  const escapedRegex = `(\\\\W|^)${symbol.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}(\\\\W|$)`\n  return {\n    kind: MatchableType.Symbol,\n    regexp: new RegExp(escapedRegex, 'g'),\n  }\n}\n\nexport function textMatchable(query: string) {\n  const escapedQuery = query.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n  return {\n    kind: MatchableType.Text,\n    regexp: new RegExp(escapedQuery, 'gi'),\n  }\n}\n\nexport function* getMatchGenerator(regex: Matchable, lines: string[], startFromLine = 0) {\n  for (let line = startFromLine; line < lines.length; line++) {\n    const snippet = lines[line]!\n\n    let match: RegExpExecArray | null\n\n    while ((match = regex.regexp.exec(snippet)) !== null) {\n      let matchContent = match[0]\n      let column = match.index\n\n      // Symbol matcher regex match leading whitespace, but don't actually include\n      // that in the match positions! This is necessary because regex\n      // lookbehinds aren't widely supported in browsers...\n      if (regex.kind === MatchableType.Symbol) {\n        if (matchContent.length > 0 && /\\W/.test(matchContent[0]!)) {\n          matchContent = matchContent.substring(1)\n          column += match[0].length - matchContent.length\n        }\n        if (matchContent.length > 0 && /\\W/.test(matchContent[matchContent.length - 1]!)) {\n          matchContent = matchContent.substring(0, matchContent.length - 1)\n        }\n      }\n\n      yield {\n        line,\n        column,\n        columnEnd: column + matchContent.length,\n        text: snippet,\n      }\n    }\n  }\n}\n","import type {Repository} from '@github-ui/current-repository'\n\nimport type {RefInfo} from '@github-ui/repos-types'\nimport type {BlackbirdSymbol, StylingDirectivesDocument} from '@github-ui/code-view-types'\nimport {CodeReference, CodeSymbol, SymbolSource} from './code-symbol'\nimport type {AlephSymbol, CodeNavBackendType} from './code-nav-types'\n\ninterface Options {\n  stylingDirectives: StylingDirectivesDocument | undefined\n  path: string\n  repo: Repository\n  refInfo: RefInfo\n}\n\ninterface AlephSymbolOptions extends Options {\n  backend: CodeNavBackendType\n}\n\nexport function outlineSymbolToCodeSymbol(\n  outlineSymbol: BlackbirdSymbol,\n  snippet: string,\n  {stylingDirectives, repo, refInfo, path}: Options,\n): CodeSymbol {\n  const {extent_utf16: extentUtf16, ident_utf16: identUtf16} = outlineSymbol\n\n  const codeSymbol = new CodeSymbol({\n    kind: outlineSymbol.kind,\n    fullyQualifiedName: outlineSymbol.fully_qualified_name,\n    name: outlineSymbol.name,\n    extent: {\n      start: {line: extentUtf16.start.line_number, column: extentUtf16.start.utf16_col},\n      end: {line: extentUtf16.end.line_number, column: extentUtf16.end.utf16_col},\n    },\n    ident: {\n      start: {line: identUtf16.start.line_number, column: identUtf16.start.utf16_col},\n      end: {line: identUtf16.end.line_number, column: identUtf16.end.utf16_col},\n    },\n    source: SymbolSource.BLACKBIRD_ANALYSIS,\n  })\n\n  codeSymbol.setSnippet(undefined, stylingDirectives?.[identUtf16.start.line_number], snippet, undefined)\n  codeSymbol.setFileInfo(repo, refInfo, path)\n\n  return codeSymbol\n}\n\nexport function alephSymbolToCodeSymbol(\n  alephSymbol: AlephSymbol,\n  {symbol, refInfo, repo, path, backend}: AlephSymbolOptions & {symbol: string},\n): CodeSymbol {\n  const symbolStartIdx = alephSymbol.ident?.start?.character\n  const symbolEndIdx = alephSymbol.ident?.end?.character ?? alephSymbol.ident?.start?.character\n  const ident = {\n    start: {\n      line: alephSymbol.ident.start.line,\n      column: symbolStartIdx ? symbolStartIdx - alephSymbol.leadingWhitespace : 0,\n    },\n    end: {\n      line: alephSymbol.ident?.end?.line ?? alephSymbol.ident.start.line,\n      column: symbolEndIdx ? symbolEndIdx - alephSymbol.leadingWhitespace : 0,\n    },\n  }\n\n  const extentStartIdx = alephSymbol.extent?.start?.character\n  const extentEndIdx = alephSymbol.extent?.end?.character ?? alephSymbol.extent?.start?.character\n  const extent = {\n    start: {\n      line: alephSymbol.extent.start.line,\n      column: extentStartIdx ? extentStartIdx : 0,\n    },\n    end: {\n      line: alephSymbol.extent.end?.line ?? alephSymbol.extent.start.line,\n      column: extentEndIdx ? extentEndIdx : 0,\n    },\n  }\n\n  const codeSymbol = new CodeSymbol({\n    ident,\n    extent,\n    kind: alephSymbol.symbolKind,\n    name: symbol,\n    // I guess aleph doesn't support fully qualified names? Just use the name\n    fullyQualifiedName: symbol,\n    source: backend === 'search' ? SymbolSource.BLACKBIRD_SEARCH : SymbolSource.ALEPH_PRECISE,\n  })\n\n  if (alephSymbol.local) {\n    codeSymbol.setFileInfo(repo, refInfo, path)\n  } else if (alephSymbol.commitOid && alephSymbol.path) {\n    let symbolRefInfo = refInfo\n\n    if (alephSymbol.commitOid !== refInfo.currentOid) {\n      symbolRefInfo = {\n        name: '',\n        listCacheKey: alephSymbol.commitOid,\n        currentOid: alephSymbol.commitOid,\n        canEdit: false,\n      }\n    }\n\n    codeSymbol.setFileInfo(alephSymbol.repo ?? repo, symbolRefInfo, alephSymbol.path)\n  }\n\n  const whiteSpace = new Array(alephSymbol.leadingWhitespace).fill(' ').join('')\n  const firstLineWithWhiteSpace = whiteSpace + (alephSymbol.firstLine || '')\n  codeSymbol.setSnippet(alephSymbol.highlightedText, undefined, firstLineWithWhiteSpace, alephSymbol.leadingWhitespace)\n  return codeSymbol\n}\n\nexport function alephSymbolToCodeReference(\n  alephSymbol: AlephSymbol,\n  {refInfo, path, repo, backend}: AlephSymbolOptions,\n): CodeReference {\n  let symbolRefInfo = refInfo\n  let symbolPath = path\n\n  if (!alephSymbol.local && alephSymbol.commitOid && alephSymbol.path) {\n    symbolRefInfo = refInfo\n    symbolPath = alephSymbol.path\n\n    if (alephSymbol.commitOid !== refInfo.currentOid) {\n      symbolRefInfo = {\n        name: '',\n        listCacheKey: alephSymbol.commitOid,\n        currentOid: alephSymbol.commitOid,\n\n        // TODO: this is probably the wrong value sometimes... but we most\n        // likely won't read this field\n        canEdit: false,\n      }\n    }\n  }\n\n  const identStartSymbolIdx = alephSymbol.ident.start.character\n  const identEndSymbolIdx = alephSymbol.ident.end?.character\n  const codeReference = new CodeReference({\n    repo,\n    refInfo: symbolRefInfo,\n    path: symbolPath,\n    ident: {\n      start: {\n        line: alephSymbol.ident.start.line,\n        column: identStartSymbolIdx ? identStartSymbolIdx - alephSymbol.leadingWhitespace : 0,\n      },\n      end: {\n        line: alephSymbol.ident.end?.line || alephSymbol.ident.start.line,\n        column: identEndSymbolIdx ? identEndSymbolIdx - alephSymbol.leadingWhitespace : 0,\n      },\n    },\n    source: backend === 'search' ? SymbolSource.BLACKBIRD_SEARCH : SymbolSource.ALEPH_PRECISE,\n  })\n\n  const firstLineWithWhiteSpace =\n    new Array(alephSymbol.leadingWhitespace).fill(' ').join('') + (alephSymbol.firstLine || '')\n  codeReference.setSnippet(\n    alephSymbol.highlightedText,\n    undefined,\n    firstLineWithWhiteSpace,\n    alephSymbol.leadingWhitespace,\n  )\n  return codeReference\n}\n","import {filterMap} from './filter-map'\n\nexport type MapKey<T, K> = (item: T) => K | null | undefined\nexport type Comparator<T> = (a: T, b: T) => number\n\nexport function filterSort<T, K>(items: T[], map: MapKey<T, K>, compare: Comparator<K>): T[] {\n  const sortKey = (item: T): [T, K] | null => {\n    const key = map(item)\n    return key != null ? [item, key] : null\n  }\n  return [...filterMap(items, sortKey)].sort((a, b) => compare(a[1], b[1])).map(([item]) => item)\n}\n","export type MapFilter<T, U> = (item: T) => U | null | undefined\n\nexport function* filterMap<T, U>(items: T[], map: MapFilter<T, U>): Iterable<U> {\n  for (const item of items) {\n    const value = map(item)\n    if (value != null) {\n      yield value\n    }\n  }\n}\n","// Example\n// ```js\n//     fuzzyScore(\"foo.html\", \"foo\")\n//     // => 0.6458333333333334\n// ```\n//\n// ```js\n//     // Compute re once\n//     re = fuzzyRegexp(\"foo\")\n//     fuzzyScore(\"foo.html\", re)\n//     fuzzyScore(\"bar.html\", re)\n//     // => 0.6458333333333334\n// ```\n//\n// Returns a number between 0 and 1. 0 being the worst match and 1\n// being an exact match.\n// You can change the `prefixBonusWeight` variable to alter ordering.\n// Currently fuzzy search for the labels picker uses a weaker prefix bonus to weight heavier full word matches.\nexport function fuzzyScore(string: string, query: string, prefixBonusWeight = 0.1): number {\n  let score = stringScore(string, query, prefixBonusWeight)\n  if (score && query.indexOf('/') === -1) {\n    const basename = string.substring(string.lastIndexOf('/') + 1)\n    score += stringScore(basename, query, prefixBonusWeight)\n  }\n  return score\n}\n\n// Create a regexp that can be used to fuzzy match a given string. Any\n// special regexp characters in the input string will be escaped\n// correctly.\n//\n// A query of \"bar\" becomes /(.*)(b)([^a]*?)(a)([^r]*?)(r)(.*?)/.\n//\n// /\n//  (.*)     whatever's before the first b\n//  (b)      grab the first b of bar\n//  ([^a]*?) take everything up to the a of bar\n//  (a)      take the a of bar\n//  ([^r]*?) take everything up to the r of bar\n//  (r)      take the r of bar\n//  (.*?)    take the rest of the string\n// /\nexport function fuzzyRegexp(query: string): RegExp {\n  const chars = query.toLowerCase().split('')\n\n  let regex = ''\n\n  let firstChar = true\n  for (const char of chars) {\n    // must escape these chars so we match literals\n    const c = char.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n    if (firstChar) {\n      // for the first we want to greedily match anything, which pushes\n      // the first match as late as possible in the string\n      regex += `(.*)(${c})`\n      firstChar = false\n    } else {\n      regex += `([^${c}]*?)(${c})`\n    }\n  }\n  return new RegExp(`${regex}(.*?)$`, 'i')\n}\n\nexport function fuzzyHighlightElement(content: Element, text?: string, textRe?: RegExp): void {\n  if (text) {\n    const matches = content.innerHTML.trim().match(textRe || fuzzyRegexp(text))\n    if (!matches) return\n\n    let open = false\n    const html = []\n    for (let i = 1; i < matches.length; ++i) {\n      const m = matches[i]\n      if (!m) continue\n\n      if (i % 2 === 0) {\n        if (!open) {\n          // eslint-disable-next-line github/unescaped-html-literal\n          html.push('<mark>')\n          open = true\n        }\n      } else if (open) {\n        html.push('</mark>')\n        open = false\n      }\n      html.push(m)\n    }\n    content.innerHTML = html.join('')\n  } else {\n    const html = content.innerHTML.trim()\n    const clean = html.replace(/<\\/?mark>/g, '')\n    if (html !== clean) {\n      content.innerHTML = clean\n    }\n  }\n}\n\nconst wordSeparators = new Set([' ', '-', '_'])\n\n// string_score.js: Quicksilver-like string scoring algorithm.\n//  https://raw.github.com/joshaven/string_score/master/coffee/string_score.coffee\n//\n// Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\n// Copyright (C) 2010-2011 Yesudeep Mangalapilly <yesudeep@gmail.com>\n// MIT license: http://www.opensource.org/licenses/mit-license.php\n//\n// A string score implementation.\nfunction stringScore(originalString: string, abbreviation: string, prefixBonusWeight = 0.1): number {\n  let string = originalString\n  if (string === abbreviation) {\n    return 1.0\n  }\n  const stringLength = string.length\n  let totalCharacterScore = 0.0\n  let shouldAwardCommonPrefixBonus = 0\n  let firstChar = true\n  for (const char of abbreviation) {\n    const indexCLowercase = string.indexOf(char.toLowerCase())\n    const indexCUppercase = string.indexOf(char.toUpperCase())\n    const minIndex = Math.min(indexCLowercase, indexCUppercase)\n    const indexInString = minIndex > -1 ? minIndex : Math.max(indexCLowercase, indexCUppercase)\n    if (indexInString === -1) {\n      return 0.0\n    }\n    totalCharacterScore += 0.1\n    if (string[indexInString] === char) {\n      totalCharacterScore += 0.1\n    }\n    if (indexInString === 0) {\n      totalCharacterScore += 0.9 - prefixBonusWeight\n      if (firstChar) {\n        shouldAwardCommonPrefixBonus = 1\n      }\n    }\n    if (wordSeparators.has(string.charAt(indexInString - 1))) {\n      totalCharacterScore += 0.9 - prefixBonusWeight\n    }\n    string = string.substring(indexInString + 1, stringLength)\n    firstChar = false\n  }\n  const abbreviationLength = abbreviation.length\n  const abbreviationScore = totalCharacterScore / abbreviationLength\n  let finalScore = (abbreviationScore * (abbreviationLength / stringLength) + abbreviationScore) / 2\n  if (shouldAwardCommonPrefixBonus && finalScore + prefixBonusWeight < 1) {\n    finalScore += prefixBonusWeight\n  }\n  return finalScore\n}\n\nexport type TextScore = {score: number; text: string}\nexport function compare(a: TextScore, b: TextScore): -1 | 0 | 1 {\n  if (a.score > b.score) {\n    return -1\n  } else if (a.score < b.score) {\n    return 1\n  } else if (a.text < b.text) {\n    return -1\n  } else if (a.text > b.text) {\n    return 1\n  } else {\n    return 0\n  }\n}\n"],"names":["parseBlobRange","str","lines","match","length","offset","parseBlobOffset","Object","freeze","start","end","startOffset","endOffset","ascendingBlobRange","formatBlobRange","blobRange","column","line","parseFileAnchor","anchorPrefix","parseAnchorPrefix","formatBlobRangeAnchor","lineMatch","columnMatch","parseInt","DOMRangeFromBlob","getLineElement","startContainer","_startOffset","findRangeOffset","endContainer","_endOffset","childNodes","ownerDocument","range","createRange","setStart","setEnd","lookAhead","error","lineElement","textNodes","getAllTextNodes","el","nodeType","Node","TEXT_NODE","list","node","concat","i","textNode","nextC","textContent","nextTextNode","offsets","sort","compareBlobOffsets","a","b","CodeNavigationInfo","initCodeSections","m","Map","lineToSectionMap","symbols","lineNumber","extent","section","startLine","endLine","index","collapsed","level","depth","has","tempArray","get","push","set","j","codeSections","initSymbols","map","outlineSymbol","snippet","blobLines","ident_utf16","line_number","codeSymbol","outlineSymbolToCodeSymbol","stylingDirectives","repo","refInfo","path","lineIndexedSymbols","getBlobLine","getSymbolOnLine","initSymbolTree","tempParents","symbolTree","filter","s","kind","fullName","symbol","symbolB","symbolA","pop","setSymbolDepth","nextSymbol","symbolChildren","buildSymbolTreeChildren","currentIndex","tempSymbol","tempChildren","determineTotalNumberOfChildren","children","isParent","createReferences","matches","reference","CodeReference","ident","isPlain","source","SymbolSource","BLOB_CONTENT","setSnippet","undefined","getReferencesToSymbol","symbolName","ranges","searchInBlobContent","symbolMatchable","getReferencesToSearch","term","textMatchable","getDefinitionsAndReferences","text","row","setLoading","defs","selectedSymbol","name","definitions","backend","getAlephDefinitions","loggedIn","localDefinitions","getLocalDefinitions","localDefinition","find","d","localDefinitionsForKindFallback","definition","SymbolKind","localRefs","definitionLines","references","r","includes","alephRefs","symbolKind","sym","enumStringVal","getAlephReferences","localReferences","crossReferences","getSymbolKind","bestRank","rank","response","resultDetails","definitionsUrl","codeNavigationPath","type","q","language","ref","codeNavContext","verifiedFetchJSON","ok","json","parseAlephBackendType","payload","flatMap","refs","alephSymbol","alephSymbolToCodeSymbol","referencesUrl","partialResponse","observedLines","Set","isCheckedLine","add","reduce","results","alephSymbolToCodeReference","constructor","rawLines","fromAleph","total","currNode","output","getMatchGenerator","next","done","columnEnd","value","searchInBlobIncrementally","codeRefs","matchable","startedAtResultLimit","checkedLine","searchResults","startFromLine","matchesInRawBlob","convertBlackbirdSymbolKind","toString","replace","toLowerCase","startsWith","enumVal","toUpperCase","shortName","symbolKindShortName","substring","plColor","symbolKindColor","class","struct","enum","interface","trait","module","implementation","function","method","call","field","CodeSymbol","setFileInfo","highlightedText","bodyText","leadingWhitespace","href","window","location","pathname","commitish","defaultBranch","currentOid","blobPath","owner","ownerLogin","filePath","pathKey","fullyQualifiedName","blame","params","plain","blamePath","MatchableType","regexp","query","regex","exec","matchContent","test","extent_utf16","extentUtf16","identUtf16","fully_qualified_name","utf16_col","BLACKBIRD_ANALYSIS","symbolStartIdx","character","symbolEndIdx","extentStartIdx","extentEndIdx","BLACKBIRD_SEARCH","ALEPH_PRECISE","local","commitOid","symbolRefInfo","listCacheKey","canEdit","firstLineWithWhiteSpace","whiteSpace","fill","join","firstLine","symbolPath","identStartSymbolIdx","identEndSymbolIdx","codeReference","filterSort","items","compare","filterMap","item","key","fuzzyScore","string","prefixBonusWeight","score","stringScore","indexOf","lastIndexOf","fuzzyHighlightElement","content","textRe","innerHTML","trim","fuzzyRegexp","chars","split","firstChar","char","c","open","html","clean","wordSeparators","originalString","abbreviation","stringLength","totalCharacterScore","shouldAwardCommonPrefixBonus","indexCLowercase","indexCUppercase","minIndex","Math","min","indexInString","max","charAt","abbreviationLength","abbreviationScore","finalScore"],"sourceRoot":""}